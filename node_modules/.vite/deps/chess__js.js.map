{
  "version": 3,
  "sources": ["../../chess.js/src/chess.ts"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nexport const WHITE = 'w'\r\nexport const BLACK = 'b'\r\n\r\nexport const PAWN = 'p'\r\nexport const KNIGHT = 'n'\r\nexport const BISHOP = 'b'\r\nexport const ROOK = 'r'\r\nexport const QUEEN = 'q'\r\nexport const KING = 'k'\r\n\r\nexport type Color = 'w' | 'b'\r\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\r\n\r\n// prettier-ignore\r\nexport type Square =\r\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\r\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\r\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\r\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\r\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\r\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\r\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\r\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\r\n\r\nexport const DEFAULT_POSITION =\r\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\r\n\r\nexport type Piece = {\r\n  color: Color\r\n  type: PieceSymbol\r\n}\r\n\r\ntype InternalMove = {\r\n  color: Color\r\n  from: number\r\n  to: number\r\n  piece: PieceSymbol\r\n  captured?: PieceSymbol\r\n  promotion?: PieceSymbol\r\n  flags: number\r\n}\r\n\r\ninterface History {\r\n  move: InternalMove\r\n  kings: Record<Color, number>\r\n  turn: Color\r\n  castling: Record<Color, number>\r\n  epSquare: number\r\n  halfMoves: number\r\n  moveNumber: number\r\n}\r\n\r\nexport class Move {\r\n  color: Color\r\n  from: Square\r\n  to: Square\r\n  piece: PieceSymbol\r\n  captured?: PieceSymbol\r\n  promotion?: PieceSymbol\r\n\r\n  /**\r\n   * @deprecated This field is deprecated and will be removed in version 2.0.0.\r\n   * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\r\n   * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\r\n   * `isBigPawn`\r\n   */\r\n  flags: string\r\n\r\n  san: string\r\n  lan: string\r\n  before: string\r\n  after: string\r\n\r\n  constructor(chess: Chess, internal: InternalMove) {\r\n    const { color, piece, from, to, flags, captured, promotion } = internal\r\n\r\n    const fromAlgebraic = algebraic(from)\r\n    const toAlgebraic = algebraic(to)\r\n\r\n    this.color = color\r\n    this.piece = piece\r\n    this.from = fromAlgebraic\r\n    this.to = toAlgebraic\r\n\r\n    /*\r\n     * HACK: The chess['_method']() calls below invoke private methods in the\r\n     * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\r\n     * code cleaner elsewhere.\r\n     */\r\n\r\n    this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }))\r\n    this.lan = fromAlgebraic + toAlgebraic\r\n    this.before = chess.fen()\r\n\r\n    // Generate the FEN for the 'after' key\r\n    chess['_makeMove'](internal)\r\n    this.after = chess.fen()\r\n    chess['_undoMove']()\r\n\r\n    // Build the text representation of the move flags\r\n    this.flags = ''\r\n    for (const flag in BITS) {\r\n      if (BITS[flag] & flags) {\r\n        this.flags += FLAGS[flag]\r\n      }\r\n    }\r\n\r\n    if (captured) {\r\n      this.captured = captured\r\n    }\r\n\r\n    if (promotion) {\r\n      this.promotion = promotion\r\n      this.lan += promotion\r\n    }\r\n  }\r\n\r\n  isCapture() {\r\n    return this.flags.indexOf(FLAGS['CAPTURE']) > -1\r\n  }\r\n\r\n  isPromotion() {\r\n    return this.flags.indexOf(FLAGS['PROMOTION']) > -1\r\n  }\r\n\r\n  isEnPassant() {\r\n    return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1\r\n  }\r\n\r\n  isKingsideCastle() {\r\n    return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1\r\n  }\r\n\r\n  isQueensideCastle() {\r\n    return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1\r\n  }\r\n\r\n  isBigPawn() {\r\n    return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1\r\n  }\r\n}\r\n\r\nconst EMPTY = -1\r\n\r\nconst FLAGS: Record<string, string> = {\r\n  NORMAL: 'n',\r\n  CAPTURE: 'c',\r\n  BIG_PAWN: 'b',\r\n  EP_CAPTURE: 'e',\r\n  PROMOTION: 'p',\r\n  KSIDE_CASTLE: 'k',\r\n  QSIDE_CASTLE: 'q',\r\n}\r\n\r\n// prettier-ignore\r\nexport const SQUARES: Square[] = [\r\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\r\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\r\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\r\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\r\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\r\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\r\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\r\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\r\n]\r\n\r\nconst BITS: Record<string, number> = {\r\n  NORMAL: 1,\r\n  CAPTURE: 2,\r\n  BIG_PAWN: 4,\r\n  EP_CAPTURE: 8,\r\n  PROMOTION: 16,\r\n  KSIDE_CASTLE: 32,\r\n  QSIDE_CASTLE: 64,\r\n}\r\n\r\n/*\r\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\r\n * ----------------------------------------------------------------------------\r\n * From https://github.com/jhlywa/chess.js/issues/230\r\n *\r\n * A lot of people are confused when they first see the internal representation\r\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\r\n * stores the board as an 8x16 array. This is purely for efficiency but has a\r\n * couple of interesting benefits:\r\n *\r\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\r\n *    square with 0x88, if the result is non-zero then the square is off the\r\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\r\n *    there are 8 possible directions in which the knight can move. These\r\n *    directions are relative to the 8x16 board and are stored in the\r\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\r\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\r\n *    (because of two-complement representation of -18). The non-zero result\r\n *    means the square is off the board and the move is illegal. Take the\r\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\r\n *    means the square is on the board.\r\n *\r\n * 2. The relative distance (or difference) between two squares on a 8x16 board\r\n *    is unique and can be used to inexpensively determine if a piece on a\r\n *    square can attack any other arbitrary square. For example, let's see if a\r\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\r\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\r\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\r\n *    bitmask of pieces that can attack from that distance and direction.\r\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\r\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\r\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\r\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\r\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\r\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\r\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\r\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\r\n */\r\n\r\n// prettier-ignore\r\n// eslint-disable-next-line\r\nconst Ox88: Record<Square, number> = {\r\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\r\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\r\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\r\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\r\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\r\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\r\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n}\r\n\r\nconst PAWN_OFFSETS = {\r\n  b: [16, 32, 17, 15],\r\n  w: [-16, -32, -17, -15],\r\n}\r\n\r\nconst PIECE_OFFSETS = {\r\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n  b: [-17, -15, 17, 15],\r\n  r: [-16, 1, 16, -1],\r\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n}\r\n\r\n// prettier-ignore\r\nconst ATTACKS = [\r\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\r\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\r\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\r\n];\r\n\r\n// prettier-ignore\r\nconst RAYS = [\r\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\r\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\r\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\r\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\r\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\r\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\r\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\r\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\r\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\r\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\r\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\r\n];\r\n\r\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\r\n\r\nconst SYMBOLS = 'pnbrqkPNBRQK'\r\n\r\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\r\n\r\nconst RANK_1 = 7\r\nconst RANK_2 = 6\r\n/*\r\n * const RANK_3 = 5\r\n * const RANK_4 = 4\r\n * const RANK_5 = 3\r\n * const RANK_6 = 2\r\n */\r\nconst RANK_7 = 1\r\nconst RANK_8 = 0\r\n\r\nconst SIDES = {\r\n  [KING]: BITS.KSIDE_CASTLE,\r\n  [QUEEN]: BITS.QSIDE_CASTLE,\r\n}\r\n\r\nconst ROOKS = {\r\n  w: [\r\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\r\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\r\n  ],\r\n  b: [\r\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\r\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\r\n  ],\r\n}\r\n\r\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\r\n\r\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\r\n\r\n// Extracts the zero-based rank of an 0x88 square.\r\nfunction rank(square: number): number {\r\n  return square >> 4\r\n}\r\n\r\n// Extracts the zero-based file of an 0x88 square.\r\nfunction file(square: number): number {\r\n  return square & 0xf\r\n}\r\n\r\nfunction isDigit(c: string): boolean {\r\n  return '0123456789'.indexOf(c) !== -1\r\n}\r\n\r\n// Converts a 0x88 square to algebraic notation.\r\nfunction algebraic(square: number): Square {\r\n  const f = file(square)\r\n  const r = rank(square)\r\n  return ('abcdefgh'.substring(f, f + 1) +\r\n    '87654321'.substring(r, r + 1)) as Square\r\n}\r\n\r\nfunction swapColor(color: Color): Color {\r\n  return color === WHITE ? BLACK : WHITE\r\n}\r\n\r\nexport function validateFen(fen: string): { ok: boolean; error?: string } {\r\n  // 1st criterion: 6 space-seperated fields?\r\n  const tokens = fen.split(/\\s+/)\r\n  if (tokens.length !== 6) {\r\n    return {\r\n      ok: false,\r\n      error: 'Invalid FEN: must contain six space-delimited fields',\r\n    }\r\n  }\r\n\r\n  // 2nd criterion: move number field is a integer value > 0?\r\n  const moveNumber = parseInt(tokens[5], 10)\r\n  if (isNaN(moveNumber) || moveNumber <= 0) {\r\n    return {\r\n      ok: false,\r\n      error: 'Invalid FEN: move number must be a positive integer',\r\n    }\r\n  }\r\n\r\n  // 3rd criterion: half move counter is an integer >= 0?\r\n  const halfMoves = parseInt(tokens[4], 10)\r\n  if (isNaN(halfMoves) || halfMoves < 0) {\r\n    return {\r\n      ok: false,\r\n      error:\r\n        'Invalid FEN: half move counter number must be a non-negative integer',\r\n    }\r\n  }\r\n\r\n  // 4th criterion: 4th field is a valid e.p.-string?\r\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\r\n  }\r\n\r\n  // 5th criterion: 3th field is a valid castle-string?\r\n  if (/[^kKqQ-]/.test(tokens[2])) {\r\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\r\n  }\r\n\r\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\r\n  if (!/^(w|b)$/.test(tokens[1])) {\r\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\r\n  }\r\n\r\n  // 7th criterion: 1st field contains 8 rows?\r\n  const rows = tokens[0].split('/')\r\n  if (rows.length !== 8) {\r\n    return {\r\n      ok: false,\r\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\r\n    }\r\n  }\r\n\r\n  // 8th criterion: every row is valid?\r\n  for (let i = 0; i < rows.length; i++) {\r\n    // check for right sum of fields AND not two numbers in succession\r\n    let sumFields = 0\r\n    let previousWasNumber = false\r\n\r\n    for (let k = 0; k < rows[i].length; k++) {\r\n      if (isDigit(rows[i][k])) {\r\n        if (previousWasNumber) {\r\n          return {\r\n            ok: false,\r\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\r\n          }\r\n        }\r\n        sumFields += parseInt(rows[i][k], 10)\r\n        previousWasNumber = true\r\n      } else {\r\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n          return {\r\n            ok: false,\r\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\r\n          }\r\n        }\r\n        sumFields += 1\r\n        previousWasNumber = false\r\n      }\r\n    }\r\n    if (sumFields !== 8) {\r\n      return {\r\n        ok: false,\r\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\r\n      }\r\n    }\r\n  }\r\n\r\n  // 9th criterion: is en-passant square legal?\r\n  if (\r\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n    (tokens[3][1] == '6' && tokens[1] == 'b')\r\n  ) {\r\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\r\n  }\r\n\r\n  // 10th criterion: does chess position contain exact two kings?\r\n  const kings = [\r\n    { color: 'white', regex: /K/g },\r\n    { color: 'black', regex: /k/g },\r\n  ]\r\n\r\n  for (const { color, regex } of kings) {\r\n    if (!regex.test(tokens[0])) {\r\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\r\n    }\r\n\r\n    if ((tokens[0].match(regex) || []).length > 1) {\r\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\r\n    }\r\n  }\r\n\r\n  // 11th criterion: are any pawns on the first or eighth rows?\r\n  if (\r\n    Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')\r\n  ) {\r\n    return {\r\n      ok: false,\r\n      error: 'Invalid FEN: some pawns are on the edge rows',\r\n    }\r\n  }\r\n\r\n  return { ok: true }\r\n}\r\n\r\n// this function is used to uniquely identify ambiguous moves\r\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]): string {\r\n  const from = move.from\r\n  const to = move.to\r\n  const piece = move.piece\r\n\r\n  let ambiguities = 0\r\n  let sameRank = 0\r\n  let sameFile = 0\r\n\r\n  for (let i = 0, len = moves.length; i < len; i++) {\r\n    const ambigFrom = moves[i].from\r\n    const ambigTo = moves[i].to\r\n    const ambigPiece = moves[i].piece\r\n\r\n    /*\r\n     * if a move of the same piece type ends on the same to square, we'll need\r\n     * to add a disambiguator to the algebraic notation\r\n     */\r\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\r\n      ambiguities++\r\n\r\n      if (rank(from) === rank(ambigFrom)) {\r\n        sameRank++\r\n      }\r\n\r\n      if (file(from) === file(ambigFrom)) {\r\n        sameFile++\r\n      }\r\n    }\r\n  }\r\n\r\n  if (ambiguities > 0) {\r\n    if (sameRank > 0 && sameFile > 0) {\r\n      /*\r\n       * if there exists a similar moving piece on the same rank and file as\r\n       * the move in question, use the square as the disambiguator\r\n       */\r\n      return algebraic(from)\r\n    } else if (sameFile > 0) {\r\n      /*\r\n       * if the moving piece rests on the same file, use the rank symbol as the\r\n       * disambiguator\r\n       */\r\n      return algebraic(from).charAt(1)\r\n    } else {\r\n      // else use the file symbol\r\n      return algebraic(from).charAt(0)\r\n    }\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nfunction addMove(\r\n  moves: InternalMove[],\r\n  color: Color,\r\n  from: number,\r\n  to: number,\r\n  piece: PieceSymbol,\r\n  captured: PieceSymbol | undefined = undefined,\r\n  flags: number = BITS.NORMAL,\r\n) {\r\n  const r = rank(to)\r\n\r\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\r\n    for (let i = 0; i < PROMOTIONS.length; i++) {\r\n      const promotion = PROMOTIONS[i]\r\n      moves.push({\r\n        color,\r\n        from,\r\n        to,\r\n        piece,\r\n        captured,\r\n        promotion,\r\n        flags: flags | BITS.PROMOTION,\r\n      })\r\n    }\r\n  } else {\r\n    moves.push({\r\n      color,\r\n      from,\r\n      to,\r\n      piece,\r\n      captured,\r\n      flags,\r\n    })\r\n  }\r\n}\r\n\r\nfunction inferPieceType(san: string): PieceSymbol | undefined {\r\n  let pieceType = san.charAt(0)\r\n  if (pieceType >= 'a' && pieceType <= 'h') {\r\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\r\n    if (matches) {\r\n      return undefined\r\n    }\r\n    return PAWN\r\n  }\r\n  pieceType = pieceType.toLowerCase()\r\n  if (pieceType === 'o') {\r\n    return KING\r\n  }\r\n  return pieceType as PieceSymbol\r\n}\r\n\r\n// parses all of the decorators out of a SAN string\r\nfunction strippedSan(move: string): string {\r\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\r\n}\r\n\r\nfunction trimFen(fen: string): string {\r\n  /*\r\n   * remove last two fields in FEN string as they're not needed when checking\r\n   * for repetition\r\n   */\r\n  return fen.split(' ').slice(0, 4).join(' ')\r\n}\r\n\r\nexport class Chess {\r\n  private _board = new Array<Piece>(128)\r\n  private _turn: Color = WHITE\r\n  private _header: Record<string, string> = {}\r\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\r\n  private _epSquare = -1\r\n  private _halfMoves = 0\r\n  private _moveNumber = 0\r\n  private _history: History[] = []\r\n  private _comments: Record<string, string> = {}\r\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\r\n\r\n  // tracks number of times a position has been seen for repetition checking\r\n  private _positionCount: Record<string, number> = {}\r\n\r\n  constructor(fen = DEFAULT_POSITION) {\r\n    this.load(fen)\r\n  }\r\n\r\n  clear({ preserveHeaders = false } = {}) {\r\n    this._board = new Array<Piece>(128)\r\n    this._kings = { w: EMPTY, b: EMPTY }\r\n    this._turn = WHITE\r\n    this._castling = { w: 0, b: 0 }\r\n    this._epSquare = EMPTY\r\n    this._halfMoves = 0\r\n    this._moveNumber = 1\r\n    this._history = []\r\n    this._comments = {}\r\n    this._header = preserveHeaders ? this._header : {}\r\n    this._positionCount = {}\r\n\r\n    /*\r\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\r\n     * these headers don't make sense in this state. They'll get added later\r\n     * via .load() or .put()\r\n     */\r\n    delete this._header['SetUp']\r\n    delete this._header['FEN']\r\n  }\r\n\r\n  load(fen: string, { skipValidation = false, preserveHeaders = false } = {}) {\r\n    let tokens = fen.split(/\\s+/)\r\n\r\n    // append commonly omitted fen tokens\r\n    if (tokens.length >= 2 && tokens.length < 6) {\r\n      const adjustments = ['-', '-', '0', '1']\r\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\r\n    }\r\n\r\n    tokens = fen.split(/\\s+/)\r\n\r\n    if (!skipValidation) {\r\n      const { ok, error } = validateFen(fen)\r\n      if (!ok) {\r\n        throw new Error(error)\r\n      }\r\n    }\r\n\r\n    const position = tokens[0]\r\n    let square = 0\r\n\r\n    this.clear({ preserveHeaders })\r\n\r\n    for (let i = 0; i < position.length; i++) {\r\n      const piece = position.charAt(i)\r\n\r\n      if (piece === '/') {\r\n        square += 8\r\n      } else if (isDigit(piece)) {\r\n        square += parseInt(piece, 10)\r\n      } else {\r\n        const color = piece < 'a' ? WHITE : BLACK\r\n        this._put(\r\n          { type: piece.toLowerCase() as PieceSymbol, color },\r\n          algebraic(square),\r\n        )\r\n        square++\r\n      }\r\n    }\r\n\r\n    this._turn = tokens[1] as Color\r\n\r\n    if (tokens[2].indexOf('K') > -1) {\r\n      this._castling.w |= BITS.KSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('Q') > -1) {\r\n      this._castling.w |= BITS.QSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('k') > -1) {\r\n      this._castling.b |= BITS.KSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('q') > -1) {\r\n      this._castling.b |= BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\r\n    this._halfMoves = parseInt(tokens[4], 10)\r\n    this._moveNumber = parseInt(tokens[5], 10)\r\n\r\n    this._updateSetup(fen)\r\n    this._incPositionCount(fen)\r\n  }\r\n\r\n  fen() {\r\n    let empty = 0\r\n    let fen = ''\r\n\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      if (this._board[i]) {\r\n        if (empty > 0) {\r\n          fen += empty\r\n          empty = 0\r\n        }\r\n        const { color, type: piece } = this._board[i]\r\n\r\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n      } else {\r\n        empty++\r\n      }\r\n\r\n      if ((i + 1) & 0x88) {\r\n        if (empty > 0) {\r\n          fen += empty\r\n        }\r\n\r\n        if (i !== Ox88.h1) {\r\n          fen += '/'\r\n        }\r\n\r\n        empty = 0\r\n        i += 8\r\n      }\r\n    }\r\n\r\n    let castling = ''\r\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\r\n      castling += 'K'\r\n    }\r\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\r\n      castling += 'Q'\r\n    }\r\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\r\n      castling += 'k'\r\n    }\r\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\r\n      castling += 'q'\r\n    }\r\n\r\n    // do we have an empty castling flag?\r\n    castling = castling || '-'\r\n\r\n    let epSquare = '-'\r\n    /*\r\n     * only print the ep square if en passant is a valid move (pawn is present\r\n     * and ep capture is not pinned)\r\n     */\r\n    if (this._epSquare !== EMPTY) {\r\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\r\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\r\n\r\n      for (const square of squares) {\r\n        // is the square off the board?\r\n        if (square & 0x88) {\r\n          continue\r\n        }\r\n\r\n        const color = this._turn\r\n\r\n        // is there a pawn that can capture the epSquare?\r\n        if (\r\n          this._board[square]?.color === color &&\r\n          this._board[square]?.type === PAWN\r\n        ) {\r\n          // if the pawn makes an ep capture, does it leave it's king in check?\r\n          this._makeMove({\r\n            color,\r\n            from: square,\r\n            to: this._epSquare,\r\n            piece: PAWN,\r\n            captured: PAWN,\r\n            flags: BITS.EP_CAPTURE,\r\n          })\r\n          const isLegal = !this._isKingAttacked(color)\r\n          this._undoMove()\r\n\r\n          // if ep is legal, break and set the ep square in the FEN output\r\n          if (isLegal) {\r\n            epSquare = algebraic(this._epSquare)\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return [\r\n      fen,\r\n      this._turn,\r\n      castling,\r\n      epSquare,\r\n      this._halfMoves,\r\n      this._moveNumber,\r\n    ].join(' ')\r\n  }\r\n\r\n  /*\r\n   * Called when the initial board setup is changed with put() or remove().\r\n   * modifies the SetUp and FEN properties of the header object. If the FEN\r\n   * is equal to the default position, the SetUp and FEN are deleted the setup\r\n   * is only updated if history.length is zero, ie moves haven't been made.\r\n   */\r\n  private _updateSetup(fen: string) {\r\n    if (this._history.length > 0) return\r\n\r\n    if (fen !== DEFAULT_POSITION) {\r\n      this._header['SetUp'] = '1'\r\n      this._header['FEN'] = fen\r\n    } else {\r\n      delete this._header['SetUp']\r\n      delete this._header['FEN']\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.load(DEFAULT_POSITION)\r\n  }\r\n\r\n  get(square: Square): Piece | undefined {\r\n    return this._board[Ox88[square]]\r\n  }\r\n\r\n  put(\r\n    { type, color }: { type: PieceSymbol; color: Color },\r\n    square: Square,\r\n  ): boolean {\r\n    if (this._put({ type, color }, square)) {\r\n      this._updateCastlingRights()\r\n      this._updateEnPassantSquare()\r\n      this._updateSetup(this.fen())\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  private _put(\r\n    { type, color }: { type: PieceSymbol; color: Color },\r\n    square: Square,\r\n  ): boolean {\r\n    // check for piece\r\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\r\n      return false\r\n    }\r\n\r\n    // check for valid square\r\n    if (!(square in Ox88)) {\r\n      return false\r\n    }\r\n\r\n    const sq = Ox88[square]\r\n\r\n    // don't let the user place more than one king\r\n    if (\r\n      type == KING &&\r\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\r\n    ) {\r\n      return false\r\n    }\r\n\r\n    const currentPieceOnSquare = this._board[sq]\r\n\r\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\r\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\r\n      this._kings[currentPieceOnSquare.color] = EMPTY\r\n    }\r\n\r\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\r\n\r\n    if (type === KING) {\r\n      this._kings[color] = sq\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  remove(square: Square): Piece | undefined {\r\n    const piece = this.get(square)\r\n    delete this._board[Ox88[square]]\r\n    if (piece && piece.type === KING) {\r\n      this._kings[piece.color] = EMPTY\r\n    }\r\n\r\n    this._updateCastlingRights()\r\n    this._updateEnPassantSquare()\r\n    this._updateSetup(this.fen())\r\n\r\n    return piece\r\n  }\r\n\r\n  private _updateCastlingRights() {\r\n    const whiteKingInPlace =\r\n      this._board[Ox88.e1]?.type === KING &&\r\n      this._board[Ox88.e1]?.color === WHITE\r\n    const blackKingInPlace =\r\n      this._board[Ox88.e8]?.type === KING &&\r\n      this._board[Ox88.e8]?.color === BLACK\r\n\r\n    if (\r\n      !whiteKingInPlace ||\r\n      this._board[Ox88.a1]?.type !== ROOK ||\r\n      this._board[Ox88.a1]?.color !== WHITE\r\n    ) {\r\n      this._castling.w &= ~BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    if (\r\n      !whiteKingInPlace ||\r\n      this._board[Ox88.h1]?.type !== ROOK ||\r\n      this._board[Ox88.h1]?.color !== WHITE\r\n    ) {\r\n      this._castling.w &= ~BITS.KSIDE_CASTLE\r\n    }\r\n\r\n    if (\r\n      !blackKingInPlace ||\r\n      this._board[Ox88.a8]?.type !== ROOK ||\r\n      this._board[Ox88.a8]?.color !== BLACK\r\n    ) {\r\n      this._castling.b &= ~BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    if (\r\n      !blackKingInPlace ||\r\n      this._board[Ox88.h8]?.type !== ROOK ||\r\n      this._board[Ox88.h8]?.color !== BLACK\r\n    ) {\r\n      this._castling.b &= ~BITS.KSIDE_CASTLE\r\n    }\r\n  }\r\n\r\n  private _updateEnPassantSquare() {\r\n    if (this._epSquare === EMPTY) {\r\n      return\r\n    }\r\n\r\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\r\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\r\n    const attackers = [currentSquare + 1, currentSquare - 1]\r\n\r\n    if (\r\n      this._board[startSquare] !== null ||\r\n      this._board[this._epSquare] !== null ||\r\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\r\n      this._board[currentSquare]?.type !== PAWN\r\n    ) {\r\n      this._epSquare = EMPTY\r\n      return\r\n    }\r\n\r\n    const canCapture = (square: number) =>\r\n      !(square & 0x88) &&\r\n      this._board[square]?.color === this._turn &&\r\n      this._board[square]?.type === PAWN\r\n\r\n    if (!attackers.some(canCapture)) {\r\n      this._epSquare = EMPTY\r\n    }\r\n  }\r\n\r\n  private _attacked(color: Color, square: number): boolean\r\n  private _attacked(color: Color, square: number, verbose: false): boolean\r\n  private _attacked(color: Color, square: number, verbose: true): Square[]\r\n  private _attacked(color: Color, square: number, verbose?: boolean) {\r\n    const attackers: Square[] = []\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      // did we run off the end of the board\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      // if empty square or wrong color\r\n      if (this._board[i] === undefined || this._board[i].color !== color) {\r\n        continue\r\n      }\r\n\r\n      const piece = this._board[i]\r\n      const difference = i - square\r\n\r\n      // skip - to/from square are the same\r\n      if (difference === 0) {\r\n        continue\r\n      }\r\n\r\n      const index = difference + 119\r\n\r\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\r\n        if (piece.type === PAWN) {\r\n          if (\r\n            (difference > 0 && piece.color === WHITE) ||\r\n            (difference <= 0 && piece.color === BLACK)\r\n          ) {\r\n            if (!verbose) {\r\n              return true\r\n            } else {\r\n              attackers.push(algebraic(i))\r\n            }\r\n          }\r\n          continue\r\n        }\r\n\r\n        // if the piece is a knight or a king\r\n        if (piece.type === 'n' || piece.type === 'k') {\r\n          if (!verbose) {\r\n            return true\r\n          } else {\r\n            attackers.push(algebraic(i))\r\n            continue\r\n          }\r\n        }\r\n\r\n        const offset = RAYS[index]\r\n        let j = i + offset\r\n\r\n        let blocked = false\r\n        while (j !== square) {\r\n          if (this._board[j] != null) {\r\n            blocked = true\r\n            break\r\n          }\r\n          j += offset\r\n        }\r\n\r\n        if (!blocked) {\r\n          if (!verbose) {\r\n            return true\r\n          } else {\r\n            attackers.push(algebraic(i))\r\n            continue\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (verbose) {\r\n      return attackers\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  attackers(square: Square, attackedBy?: Color): Square[] {\r\n    if (!attackedBy) {\r\n      return this._attacked(this._turn, Ox88[square], true)\r\n    } else {\r\n      return this._attacked(attackedBy, Ox88[square], true)\r\n    }\r\n  }\r\n\r\n  private _isKingAttacked(color: Color): boolean {\r\n    const square = this._kings[color]\r\n    return square === -1 ? false : this._attacked(swapColor(color), square)\r\n  }\r\n\r\n  isAttacked(square: Square, attackedBy: Color): boolean {\r\n    return this._attacked(attackedBy, Ox88[square])\r\n  }\r\n\r\n  isCheck(): boolean {\r\n    return this._isKingAttacked(this._turn)\r\n  }\r\n\r\n  inCheck(): boolean {\r\n    return this.isCheck()\r\n  }\r\n\r\n  isCheckmate(): boolean {\r\n    return this.isCheck() && this._moves().length === 0\r\n  }\r\n\r\n  isStalemate(): boolean {\r\n    return !this.isCheck() && this._moves().length === 0\r\n  }\r\n\r\n  isInsufficientMaterial(): boolean {\r\n    /*\r\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\r\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\r\n     *\r\n     * k.b. vs k.n. with mate in 1:\r\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\r\n     */\r\n    const pieces: Record<PieceSymbol, number> = {\r\n      b: 0,\r\n      n: 0,\r\n      r: 0,\r\n      q: 0,\r\n      k: 0,\r\n      p: 0,\r\n    }\r\n    const bishops = []\r\n    let numPieces = 0\r\n    let squareColor = 0\r\n\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      squareColor = (squareColor + 1) % 2\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      const piece = this._board[i]\r\n      if (piece) {\r\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\r\n        if (piece.type === BISHOP) {\r\n          bishops.push(squareColor)\r\n        }\r\n        numPieces++\r\n      }\r\n    }\r\n\r\n    // k vs. k\r\n    if (numPieces === 2) {\r\n      return true\r\n    } else if (\r\n      // k vs. kn .... or .... k vs. kb\r\n      numPieces === 3 &&\r\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\r\n    ) {\r\n      return true\r\n    } else if (numPieces === pieces[BISHOP] + 2) {\r\n      // kb vs. kb where any number of bishops are all on the same color\r\n      let sum = 0\r\n      const len = bishops.length\r\n      for (let i = 0; i < len; i++) {\r\n        sum += bishops[i]\r\n      }\r\n      if (sum === 0 || sum === len) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  isThreefoldRepetition(): boolean {\r\n    return this._getPositionCount(this.fen()) >= 3\r\n  }\r\n\r\n  isDrawByFiftyMoves(): boolean {\r\n    return this._halfMoves >= 100 // 50 moves per side = 100 half moves\r\n  }\r\n\r\n  isDraw(): boolean {\r\n    return (\r\n      this.isDrawByFiftyMoves() ||\r\n      this.isStalemate() ||\r\n      this.isInsufficientMaterial() ||\r\n      this.isThreefoldRepetition()\r\n    )\r\n  }\r\n\r\n  isGameOver(): boolean {\r\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\r\n  }\r\n\r\n  moves(): string[]\r\n  moves({ square }: { square: Square }): string[]\r\n  moves({ piece }: { piece: PieceSymbol }): string[]\r\n\r\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\r\n\r\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\r\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\r\n  moves({\r\n    verbose,\r\n    square,\r\n  }: {\r\n    verbose?: boolean\r\n    square?: Square\r\n  }): string[] | Move[]\r\n\r\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\r\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\r\n  moves({\r\n    verbose,\r\n    piece,\r\n  }: {\r\n    verbose?: boolean\r\n    piece?: PieceSymbol\r\n  }): string[] | Move[]\r\n\r\n  moves({\r\n    verbose,\r\n    square,\r\n    piece,\r\n  }: {\r\n    verbose: true\r\n    square?: Square\r\n    piece?: PieceSymbol\r\n  }): Move[]\r\n  moves({\r\n    verbose,\r\n    square,\r\n    piece,\r\n  }: {\r\n    verbose: false\r\n    square?: Square\r\n    piece?: PieceSymbol\r\n  }): string[]\r\n  moves({\r\n    verbose,\r\n    square,\r\n    piece,\r\n  }: {\r\n    verbose?: boolean\r\n    square?: Square\r\n    piece?: PieceSymbol\r\n  }): string[] | Move[]\r\n\r\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\r\n\r\n  moves({\r\n    verbose = false,\r\n    square = undefined,\r\n    piece = undefined,\r\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\r\n    const moves = this._moves({ square, piece })\r\n\r\n    if (verbose) {\r\n      return moves.map((move) => new Move(this, move))\r\n    } else {\r\n      return moves.map((move) => this._moveToSan(move, moves))\r\n    }\r\n  }\r\n\r\n  private _moves({\r\n    legal = true,\r\n    piece = undefined,\r\n    square = undefined,\r\n  }: {\r\n    legal?: boolean\r\n    piece?: PieceSymbol\r\n    square?: Square\r\n  } = {}): InternalMove[] {\r\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\r\n    const forPiece = piece?.toLowerCase()\r\n\r\n    const moves: InternalMove[] = []\r\n    const us = this._turn\r\n    const them = swapColor(us)\r\n\r\n    let firstSquare = Ox88.a8\r\n    let lastSquare = Ox88.h1\r\n    let singleSquare = false\r\n\r\n    // are we generating moves for a single square?\r\n    if (forSquare) {\r\n      // illegal square, return empty moves\r\n      if (!(forSquare in Ox88)) {\r\n        return []\r\n      } else {\r\n        firstSquare = lastSquare = Ox88[forSquare]\r\n        singleSquare = true\r\n      }\r\n    }\r\n\r\n    for (let from = firstSquare; from <= lastSquare; from++) {\r\n      // did we run off the end of the board\r\n      if (from & 0x88) {\r\n        from += 7\r\n        continue\r\n      }\r\n\r\n      // empty square or opponent, skip\r\n      if (!this._board[from] || this._board[from].color === them) {\r\n        continue\r\n      }\r\n      const { type } = this._board[from]\r\n\r\n      let to: number\r\n      if (type === PAWN) {\r\n        if (forPiece && forPiece !== type) continue\r\n\r\n        // single square, non-capturing\r\n        to = from + PAWN_OFFSETS[us][0]\r\n        if (!this._board[to]) {\r\n          addMove(moves, us, from, to, PAWN)\r\n\r\n          // double square\r\n          to = from + PAWN_OFFSETS[us][1]\r\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\r\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\r\n          }\r\n        }\r\n\r\n        // pawn captures\r\n        for (let j = 2; j < 4; j++) {\r\n          to = from + PAWN_OFFSETS[us][j]\r\n          if (to & 0x88) continue\r\n\r\n          if (this._board[to]?.color === them) {\r\n            addMove(\r\n              moves,\r\n              us,\r\n              from,\r\n              to,\r\n              PAWN,\r\n              this._board[to].type,\r\n              BITS.CAPTURE,\r\n            )\r\n          } else if (to === this._epSquare) {\r\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\r\n          }\r\n        }\r\n      } else {\r\n        if (forPiece && forPiece !== type) continue\r\n\r\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\r\n          const offset = PIECE_OFFSETS[type][j]\r\n          to = from\r\n\r\n          while (true) {\r\n            to += offset\r\n            if (to & 0x88) break\r\n\r\n            if (!this._board[to]) {\r\n              addMove(moves, us, from, to, type)\r\n            } else {\r\n              // own color, stop loop\r\n              if (this._board[to].color === us) break\r\n\r\n              addMove(\r\n                moves,\r\n                us,\r\n                from,\r\n                to,\r\n                type,\r\n                this._board[to].type,\r\n                BITS.CAPTURE,\r\n              )\r\n              break\r\n            }\r\n\r\n            /* break, if knight or king */\r\n            if (type === KNIGHT || type === KING) break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /*\r\n     * check for castling if we're:\r\n     *   a) generating all moves, or\r\n     *   b) doing single square move generation on the king's square\r\n     */\r\n\r\n    if (forPiece === undefined || forPiece === KING) {\r\n      if (!singleSquare || lastSquare === this._kings[us]) {\r\n        // king-side castling\r\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\r\n          const castlingFrom = this._kings[us]\r\n          const castlingTo = castlingFrom + 2\r\n\r\n          if (\r\n            !this._board[castlingFrom + 1] &&\r\n            !this._board[castlingTo] &&\r\n            !this._attacked(them, this._kings[us]) &&\r\n            !this._attacked(them, castlingFrom + 1) &&\r\n            !this._attacked(them, castlingTo)\r\n          ) {\r\n            addMove(\r\n              moves,\r\n              us,\r\n              this._kings[us],\r\n              castlingTo,\r\n              KING,\r\n              undefined,\r\n              BITS.KSIDE_CASTLE,\r\n            )\r\n          }\r\n        }\r\n\r\n        // queen-side castling\r\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\r\n          const castlingFrom = this._kings[us]\r\n          const castlingTo = castlingFrom - 2\r\n\r\n          if (\r\n            !this._board[castlingFrom - 1] &&\r\n            !this._board[castlingFrom - 2] &&\r\n            !this._board[castlingFrom - 3] &&\r\n            !this._attacked(them, this._kings[us]) &&\r\n            !this._attacked(them, castlingFrom - 1) &&\r\n            !this._attacked(them, castlingTo)\r\n          ) {\r\n            addMove(\r\n              moves,\r\n              us,\r\n              this._kings[us],\r\n              castlingTo,\r\n              KING,\r\n              undefined,\r\n              BITS.QSIDE_CASTLE,\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /*\r\n     * return all pseudo-legal moves (this includes moves that allow the king\r\n     * to be captured)\r\n     */\r\n    if (!legal || this._kings[us] === -1) {\r\n      return moves\r\n    }\r\n\r\n    // filter out illegal moves\r\n    const legalMoves = []\r\n\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      this._makeMove(moves[i])\r\n      if (!this._isKingAttacked(us)) {\r\n        legalMoves.push(moves[i])\r\n      }\r\n      this._undoMove()\r\n    }\r\n\r\n    return legalMoves\r\n  }\r\n\r\n  move(\r\n    move: string | { from: string; to: string; promotion?: string },\r\n    { strict = false }: { strict?: boolean } = {},\r\n  ): Move {\r\n    /*\r\n     * The move function can be called with in the following parameters:\r\n     *\r\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\r\n     *\r\n     * .move({ from: 'h7', <- argument is a move object\r\n     *         to :'h8',\r\n     *         promotion: 'q' })\r\n     *\r\n     *\r\n     * An optional strict argument may be supplied to tell chess.js to\r\n     * strictly follow the SAN specification.\r\n     */\r\n\r\n    let moveObj = null\r\n\r\n    if (typeof move === 'string') {\r\n      moveObj = this._moveFromSan(move, strict)\r\n    } else if (typeof move === 'object') {\r\n      const moves = this._moves()\r\n\r\n      // convert the pretty move object to an ugly move object\r\n      for (let i = 0, len = moves.length; i < len; i++) {\r\n        if (\r\n          move.from === algebraic(moves[i].from) &&\r\n          move.to === algebraic(moves[i].to) &&\r\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\r\n        ) {\r\n          moveObj = moves[i]\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // failed to find move\r\n    if (!moveObj) {\r\n      if (typeof move === 'string') {\r\n        throw new Error(`Invalid move: ${move}`)\r\n      } else {\r\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\r\n      }\r\n    }\r\n\r\n    /*\r\n     * need to make a copy of move because we can't generate SAN after the move\r\n     * is made\r\n     */\r\n    const prettyMove = new Move(this, moveObj)\r\n\r\n    this._makeMove(moveObj)\r\n    this._incPositionCount(prettyMove.after)\r\n    return prettyMove\r\n  }\r\n\r\n  private _push(move: InternalMove) {\r\n    this._history.push({\r\n      move,\r\n      kings: { b: this._kings.b, w: this._kings.w },\r\n      turn: this._turn,\r\n      castling: { b: this._castling.b, w: this._castling.w },\r\n      epSquare: this._epSquare,\r\n      halfMoves: this._halfMoves,\r\n      moveNumber: this._moveNumber,\r\n    })\r\n  }\r\n\r\n  private _makeMove(move: InternalMove) {\r\n    const us = this._turn\r\n    const them = swapColor(us)\r\n    this._push(move)\r\n\r\n    this._board[move.to] = this._board[move.from]\r\n    delete this._board[move.from]\r\n\r\n    // if ep capture, remove the captured pawn\r\n    if (move.flags & BITS.EP_CAPTURE) {\r\n      if (this._turn === BLACK) {\r\n        delete this._board[move.to - 16]\r\n      } else {\r\n        delete this._board[move.to + 16]\r\n      }\r\n    }\r\n\r\n    // if pawn promotion, replace with new piece\r\n    if (move.promotion) {\r\n      this._board[move.to] = { type: move.promotion, color: us }\r\n    }\r\n\r\n    // if we moved the king\r\n    if (this._board[move.to].type === KING) {\r\n      this._kings[us] = move.to\r\n\r\n      // if we castled, move the rook next to the king\r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        const castlingTo = move.to - 1\r\n        const castlingFrom = move.to + 1\r\n        this._board[castlingTo] = this._board[castlingFrom]\r\n        delete this._board[castlingFrom]\r\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n        const castlingTo = move.to + 1\r\n        const castlingFrom = move.to - 2\r\n        this._board[castlingTo] = this._board[castlingFrom]\r\n        delete this._board[castlingFrom]\r\n      }\r\n\r\n      // turn off castling\r\n      this._castling[us] = 0\r\n    }\r\n\r\n    // turn off castling if we move a rook\r\n    if (this._castling[us]) {\r\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\r\n        if (\r\n          move.from === ROOKS[us][i].square &&\r\n          this._castling[us] & ROOKS[us][i].flag\r\n        ) {\r\n          this._castling[us] ^= ROOKS[us][i].flag\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // turn off castling if we capture a rook\r\n    if (this._castling[them]) {\r\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\r\n        if (\r\n          move.to === ROOKS[them][i].square &&\r\n          this._castling[them] & ROOKS[them][i].flag\r\n        ) {\r\n          this._castling[them] ^= ROOKS[them][i].flag\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // if big pawn move, update the en passant square\r\n    if (move.flags & BITS.BIG_PAWN) {\r\n      if (us === BLACK) {\r\n        this._epSquare = move.to - 16\r\n      } else {\r\n        this._epSquare = move.to + 16\r\n      }\r\n    } else {\r\n      this._epSquare = EMPTY\r\n    }\r\n\r\n    // reset the 50 move counter if a pawn is moved or a piece is captured\r\n    if (move.piece === PAWN) {\r\n      this._halfMoves = 0\r\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n      this._halfMoves = 0\r\n    } else {\r\n      this._halfMoves++\r\n    }\r\n\r\n    if (us === BLACK) {\r\n      this._moveNumber++\r\n    }\r\n\r\n    this._turn = them\r\n  }\r\n\r\n  undo(): Move | null {\r\n    const move = this._undoMove()\r\n    if (move) {\r\n      const prettyMove = new Move(this, move)\r\n      this._decPositionCount(prettyMove.after)\r\n      return prettyMove\r\n    }\r\n    return null\r\n  }\r\n\r\n  private _undoMove(): InternalMove | null {\r\n    const old = this._history.pop()\r\n    if (old === undefined) {\r\n      return null\r\n    }\r\n\r\n    const move = old.move\r\n\r\n    this._kings = old.kings\r\n    this._turn = old.turn\r\n    this._castling = old.castling\r\n    this._epSquare = old.epSquare\r\n    this._halfMoves = old.halfMoves\r\n    this._moveNumber = old.moveNumber\r\n\r\n    const us = this._turn\r\n    const them = swapColor(us)\r\n\r\n    this._board[move.from] = this._board[move.to]\r\n    this._board[move.from].type = move.piece // to undo any promotions\r\n    delete this._board[move.to]\r\n\r\n    if (move.captured) {\r\n      if (move.flags & BITS.EP_CAPTURE) {\r\n        // en passant capture\r\n        let index: number\r\n        if (us === BLACK) {\r\n          index = move.to - 16\r\n        } else {\r\n          index = move.to + 16\r\n        }\r\n        this._board[index] = { type: PAWN, color: them }\r\n      } else {\r\n        // regular capture\r\n        this._board[move.to] = { type: move.captured, color: them }\r\n      }\r\n    }\r\n\r\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\r\n      let castlingTo: number, castlingFrom: number\r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        castlingTo = move.to + 1\r\n        castlingFrom = move.to - 1\r\n      } else {\r\n        castlingTo = move.to - 2\r\n        castlingFrom = move.to + 1\r\n      }\r\n\r\n      this._board[castlingTo] = this._board[castlingFrom]\r\n      delete this._board[castlingFrom]\r\n    }\r\n\r\n    return move\r\n  }\r\n\r\n  pgn({\r\n    newline = '\\n',\r\n    maxWidth = 0,\r\n  }: { newline?: string; maxWidth?: number } = {}): string {\r\n    /*\r\n     * using the specification from http://www.chessclub.com/help/PGN-spec\r\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n     */\r\n\r\n    const result: string[] = []\r\n    let headerExists = false\r\n\r\n    /* add the PGN header information */\r\n    for (const i in this._header) {\r\n      /*\r\n       * TODO: order of enumerated properties in header object is not\r\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n       */\r\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\r\n      headerExists = true\r\n    }\r\n\r\n    if (headerExists && this._history.length) {\r\n      result.push(newline)\r\n    }\r\n\r\n    const appendComment = (moveString: string) => {\r\n      const comment = this._comments[this.fen()]\r\n      if (typeof comment !== 'undefined') {\r\n        const delimiter = moveString.length > 0 ? ' ' : ''\r\n        moveString = `${moveString}${delimiter}{${comment}}`\r\n      }\r\n      return moveString\r\n    }\r\n\r\n    // pop all of history onto reversed_history\r\n    const reversedHistory = []\r\n    while (this._history.length > 0) {\r\n      reversedHistory.push(this._undoMove())\r\n    }\r\n\r\n    const moves = []\r\n    let moveString = ''\r\n\r\n    // special case of a commented starting position with no moves\r\n    if (reversedHistory.length === 0) {\r\n      moves.push(appendComment(''))\r\n    }\r\n\r\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\r\n    while (reversedHistory.length > 0) {\r\n      moveString = appendComment(moveString)\r\n      const move = reversedHistory.pop()\r\n\r\n      // make TypeScript stop complaining about move being undefined\r\n      if (!move) {\r\n        break\r\n      }\r\n\r\n      // if the position started with black to move, start PGN with #. ...\r\n      if (!this._history.length && move.color === 'b') {\r\n        const prefix = `${this._moveNumber}. ...`\r\n        // is there a comment preceding the first move?\r\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\r\n      } else if (move.color === 'w') {\r\n        // store the previous generated move_string if we have one\r\n        if (moveString.length) {\r\n          moves.push(moveString)\r\n        }\r\n        moveString = this._moveNumber + '.'\r\n      }\r\n\r\n      moveString =\r\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\r\n      this._makeMove(move)\r\n    }\r\n\r\n    // are there any other leftover moves?\r\n    if (moveString.length) {\r\n      moves.push(appendComment(moveString))\r\n    }\r\n\r\n    // is there a result?\r\n    if (typeof this._header.Result !== 'undefined') {\r\n      moves.push(this._header.Result)\r\n    }\r\n\r\n    /*\r\n     * history should be back to what it was before we started generating PGN,\r\n     * so join together moves\r\n     */\r\n    if (maxWidth === 0) {\r\n      return result.join('') + moves.join(' ')\r\n    }\r\n\r\n    // TODO (jah): huh?\r\n    const strip = function () {\r\n      if (result.length > 0 && result[result.length - 1] === ' ') {\r\n        result.pop()\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n\r\n    // NB: this does not preserve comment whitespace.\r\n    const wrapComment = function (width: number, move: string) {\r\n      for (const token of move.split(' ')) {\r\n        if (!token) {\r\n          continue\r\n        }\r\n        if (width + token.length > maxWidth) {\r\n          while (strip()) {\r\n            width--\r\n          }\r\n          result.push(newline)\r\n          width = 0\r\n        }\r\n        result.push(token)\r\n        width += token.length\r\n        result.push(' ')\r\n        width++\r\n      }\r\n      if (strip()) {\r\n        width--\r\n      }\r\n      return width\r\n    }\r\n\r\n    // wrap the PGN output at max_width\r\n    let currentWidth = 0\r\n    for (let i = 0; i < moves.length; i++) {\r\n      if (currentWidth + moves[i].length > maxWidth) {\r\n        if (moves[i].includes('{')) {\r\n          currentWidth = wrapComment(currentWidth, moves[i])\r\n          continue\r\n        }\r\n      }\r\n      // if the current move will push past max_width\r\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\r\n        // don't end the line with whitespace\r\n        if (result[result.length - 1] === ' ') {\r\n          result.pop()\r\n        }\r\n\r\n        result.push(newline)\r\n        currentWidth = 0\r\n      } else if (i !== 0) {\r\n        result.push(' ')\r\n        currentWidth++\r\n      }\r\n      result.push(moves[i])\r\n      currentWidth += moves[i].length\r\n    }\r\n\r\n    return result.join('')\r\n  }\r\n\r\n  /*\r\n   * @deprecated Use `setHeader` and `getHeaders` instead.\r\n   */\r\n  header(...args: string[]): Record<string, string> {\r\n    for (let i = 0; i < args.length; i += 2) {\r\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\r\n        this._header[args[i]] = args[i + 1]\r\n      }\r\n    }\r\n    return this._header\r\n  }\r\n\r\n  setHeader(key: string, value: string): Record<string, string> {\r\n    this._header[key] = value\r\n    return this._header\r\n  }\r\n\r\n  removeHeader(key: string): boolean {\r\n    if (key in this._header) {\r\n      delete this._header[key]\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  getHeaders(): Record<string, string> {\r\n    return this._header\r\n  }\r\n\r\n  loadPgn(\r\n    pgn: string,\r\n    {\r\n      strict = false,\r\n      newlineChar = '\\r?\\n',\r\n    }: { strict?: boolean; newlineChar?: string } = {},\r\n  ) {\r\n    function mask(str: string): string {\r\n      return str.replace(/\\\\/g, '\\\\')\r\n    }\r\n\r\n    function parsePgnHeader(header: string): { [key: string]: string } {\r\n      const headerObj: Record<string, string> = {}\r\n      const headers = header.split(new RegExp(mask(newlineChar)))\r\n      let key = ''\r\n      let value = ''\r\n\r\n      for (let i = 0; i < headers.length; i++) {\r\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\r\n        key = headers[i].replace(regex, '$1')\r\n        value = headers[i].replace(regex, '$2')\r\n        if (key.trim().length > 0) {\r\n          headerObj[key] = value\r\n        }\r\n      }\r\n\r\n      return headerObj\r\n    }\r\n\r\n    // strip whitespace from head/tail of PGN block\r\n    pgn = pgn.trim()\r\n\r\n    /*\r\n     * RegExp to split header. Takes advantage of the fact that header and movetext\r\n     * will always have a blank line between them (ie, two newline_char's). Handles\r\n     * case where movetext is empty by matching newlineChar until end of string is\r\n     * matched - effectively trimming from the end extra newlineChar.\r\n     *\r\n     * With default newline_char, will equal:\r\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\r\n     */\r\n    const headerRegex = new RegExp(\r\n      '^(\\\\[((?:' +\r\n        mask(newlineChar) +\r\n        ')|.)*\\\\])' +\r\n        '((?:\\\\s*' +\r\n        mask(newlineChar) +\r\n        '){2}|(?:\\\\s*' +\r\n        mask(newlineChar) +\r\n        ')*$)',\r\n    )\r\n\r\n    // If no header given, begin with moves.\r\n    const headerRegexResults = headerRegex.exec(pgn)\r\n    const headerString = headerRegexResults\r\n      ? headerRegexResults.length >= 2\r\n        ? headerRegexResults[1]\r\n        : ''\r\n      : ''\r\n\r\n    // Put the board in the starting position\r\n    this.reset()\r\n\r\n    // parse PGN header\r\n    const headers = parsePgnHeader(headerString)\r\n    let fen = ''\r\n\r\n    for (const key in headers) {\r\n      // check to see user is including fen (possibly with wrong tag case)\r\n      if (key.toLowerCase() === 'fen') {\r\n        fen = headers[key]\r\n      }\r\n\r\n      this.header(key, headers[key])\r\n    }\r\n\r\n    /*\r\n     * the permissive parser should attempt to load a fen tag, even if it's the\r\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\r\n     */\r\n    if (!strict) {\r\n      if (fen) {\r\n        this.load(fen, { preserveHeaders: true })\r\n      }\r\n    } else {\r\n      /*\r\n       * strict parser - load the starting position indicated by [Setup '1']\r\n       * and [FEN position]\r\n       */\r\n      if (headers['SetUp'] === '1') {\r\n        if (!('FEN' in headers)) {\r\n          throw new Error(\r\n            'Invalid PGN: FEN tag must be supplied with SetUp tag',\r\n          )\r\n        }\r\n        // don't clear the headers when loading\r\n        this.load(headers['FEN'], { preserveHeaders: true })\r\n      }\r\n    }\r\n\r\n    /*\r\n     * NB: the regexes below that delete move numbers, recursive annotations,\r\n     * and numeric annotation glyphs may also match text in comments. To\r\n     * prevent this, we transform comments by hex-encoding them in place and\r\n     * decoding them again after the other tokens have been deleted.\r\n     *\r\n     * While the spec states that PGN files should be ASCII encoded, we use\r\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\r\n     * for modern users\r\n     */\r\n\r\n    function toHex(s: string): string {\r\n      return Array.from(s)\r\n        .map(function (c) {\r\n          /*\r\n           * encodeURI doesn't transform most ASCII characters, so we handle\r\n           * these ourselves\r\n           */\r\n          return c.charCodeAt(0) < 128\r\n            ? c.charCodeAt(0).toString(16)\r\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\r\n        })\r\n        .join('')\r\n    }\r\n\r\n    function fromHex(s: string): string {\r\n      return s.length == 0\r\n        ? ''\r\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\r\n    }\r\n\r\n    const encodeComment = function (s: string): string {\r\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\r\n      return `{${toHex(s.slice(1, s.length - 1))}}`\r\n    }\r\n\r\n    const decodeComment = function (s: string) {\r\n      if (s.startsWith('{') && s.endsWith('}')) {\r\n        return fromHex(s.slice(1, s.length - 1))\r\n      }\r\n    }\r\n\r\n    // delete header to get the moves\r\n    let ms = pgn\r\n      .replace(headerString, '')\r\n      .replace(\r\n        // encode comments so they don't get deleted below\r\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\r\n        function (_match, bracket, semicolon) {\r\n          return bracket !== undefined\r\n            ? encodeComment(bracket)\r\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\r\n        },\r\n      )\r\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\r\n\r\n    // delete recursive annotation variations\r\n    const ravRegex = /(\\([^()]+\\))+?/g\r\n    while (ravRegex.test(ms)) {\r\n      ms = ms.replace(ravRegex, '')\r\n    }\r\n\r\n    // delete move numbers\r\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\r\n\r\n    // delete ... indicating black to move\r\n    ms = ms.replace(/\\.\\.\\./g, '')\r\n\r\n    /* delete numeric annotation glyphs */\r\n    ms = ms.replace(/\\$\\d+/g, '')\r\n\r\n    // trim and get array of moves\r\n    let moves = ms.trim().split(new RegExp(/\\s+/))\r\n\r\n    // delete empty entries\r\n    moves = moves.filter((move) => move !== '')\r\n\r\n    let result = ''\r\n\r\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\r\n      const comment = decodeComment(moves[halfMove])\r\n      if (comment !== undefined) {\r\n        this._comments[this.fen()] = comment\r\n        continue\r\n      }\r\n\r\n      const move = this._moveFromSan(moves[halfMove], strict)\r\n\r\n      // invalid move\r\n      if (move == null) {\r\n        // was the move an end of game marker\r\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\r\n          result = moves[halfMove]\r\n        } else {\r\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\r\n        }\r\n      } else {\r\n        // reset the end of game marker if making a valid move\r\n        result = ''\r\n        this._makeMove(move)\r\n        this._incPositionCount(this.fen())\r\n      }\r\n    }\r\n\r\n    /*\r\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\r\n     * the termination marker. Only do this when headers are present, but the\r\n     * result tag is missing\r\n     */\r\n\r\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\r\n      this.header('Result', result)\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n   * (SAN)\r\n   *\r\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\r\n   * on overly disambiguated moves (see below):\r\n   *\r\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n   * 4. ... Ne7 is technically the valid SAN\r\n   */\r\n\r\n  private _moveToSan(move: InternalMove, moves: InternalMove[]): string {\r\n    let output = ''\r\n\r\n    if (move.flags & BITS.KSIDE_CASTLE) {\r\n      output = 'O-O'\r\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n      output = 'O-O-O'\r\n    } else {\r\n      if (move.piece !== PAWN) {\r\n        const disambiguator = getDisambiguator(move, moves)\r\n        output += move.piece.toUpperCase() + disambiguator\r\n      }\r\n\r\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n        if (move.piece === PAWN) {\r\n          output += algebraic(move.from)[0]\r\n        }\r\n        output += 'x'\r\n      }\r\n\r\n      output += algebraic(move.to)\r\n\r\n      if (move.promotion) {\r\n        output += '=' + move.promotion.toUpperCase()\r\n      }\r\n    }\r\n\r\n    this._makeMove(move)\r\n    if (this.isCheck()) {\r\n      if (this.isCheckmate()) {\r\n        output += '#'\r\n      } else {\r\n        output += '+'\r\n      }\r\n    }\r\n    this._undoMove()\r\n\r\n    return output\r\n  }\r\n\r\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\r\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\r\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\r\n    const cleanMove = strippedSan(move)\r\n\r\n    let pieceType = inferPieceType(cleanMove)\r\n    let moves = this._moves({ legal: true, piece: pieceType })\r\n\r\n    // strict parser\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\r\n        return moves[i]\r\n      }\r\n    }\r\n\r\n    // the strict parser failed\r\n    if (strict) {\r\n      return null\r\n    }\r\n\r\n    let piece = undefined\r\n    let matches = undefined\r\n    let from = undefined\r\n    let to = undefined\r\n    let promotion = undefined\r\n\r\n    /*\r\n     * The default permissive (non-strict) parser allows the user to parse\r\n     * non-standard chess notations. This parser is only run after the strict\r\n     * Standard Algebraic Notation (SAN) parser has failed.\r\n     *\r\n     * When running the permissive parser, we'll run a regex to grab the piece, the\r\n     * to/from square, and an optional promotion piece. This regex will\r\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\r\n     * f7f8q, b1c3\r\n     *\r\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\r\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\r\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\r\n     * move). In these cases, the permissive parser will default to the most\r\n     * basic interpretation (which is b1c3 parsing to Nc3).\r\n     */\r\n\r\n    let overlyDisambiguated = false\r\n\r\n    matches = cleanMove.match(\r\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,\r\n      //     piece         from              to       promotion\r\n    )\r\n\r\n    if (matches) {\r\n      piece = matches[1]\r\n      from = matches[2] as Square\r\n      to = matches[3] as Square\r\n      promotion = matches[4]\r\n\r\n      if (from.length == 1) {\r\n        overlyDisambiguated = true\r\n      }\r\n    } else {\r\n      /*\r\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\r\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\r\n       * there is one legal knight move to e7). In this case, the value of\r\n       * 'from' variable will be a rank or file, not a square.\r\n       */\r\n\r\n      matches = cleanMove.match(\r\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,\r\n      )\r\n\r\n      if (matches) {\r\n        piece = matches[1]\r\n        from = matches[2] as Square\r\n        to = matches[3] as Square\r\n        promotion = matches[4]\r\n\r\n        if (from.length == 1) {\r\n          overlyDisambiguated = true\r\n        }\r\n      }\r\n    }\r\n\r\n    pieceType = inferPieceType(cleanMove)\r\n    moves = this._moves({\r\n      legal: true,\r\n      piece: piece ? (piece as PieceSymbol) : pieceType,\r\n    })\r\n\r\n    if (!to) {\r\n      return null\r\n    }\r\n\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      if (!from) {\r\n        // if there is no from square, it could be just 'x' missing from a capture\r\n        if (\r\n          cleanMove ===\r\n          strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')\r\n        ) {\r\n          return moves[i]\r\n        }\r\n        // hand-compare move properties with the results from our permissive regex\r\n      } else if (\r\n        (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n        Ox88[from] == moves[i].from &&\r\n        Ox88[to] == moves[i].to &&\r\n        (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n      ) {\r\n        return moves[i]\r\n      } else if (overlyDisambiguated) {\r\n        /*\r\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\r\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\r\n         */\r\n\r\n        const square = algebraic(moves[i].from)\r\n        if (\r\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n          Ox88[to] == moves[i].to &&\r\n          (from == square[0] || from == square[1]) &&\r\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n        ) {\r\n          return moves[i]\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  ascii(): string {\r\n    let s = '   +------------------------+\\n'\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      // display the rank\r\n      if (file(i) === 0) {\r\n        s += ' ' + '87654321'[rank(i)] + ' |'\r\n      }\r\n\r\n      if (this._board[i]) {\r\n        const piece = this._board[i].type\r\n        const color = this._board[i].color\r\n        const symbol =\r\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n        s += ' ' + symbol + ' '\r\n      } else {\r\n        s += ' . '\r\n      }\r\n\r\n      if ((i + 1) & 0x88) {\r\n        s += '|\\n'\r\n        i += 8\r\n      }\r\n    }\r\n    s += '   +------------------------+\\n'\r\n    s += '     a  b  c  d  e  f  g  h'\r\n\r\n    return s\r\n  }\r\n\r\n  perft(depth: number): number {\r\n    const moves = this._moves({ legal: false })\r\n    let nodes = 0\r\n    const color = this._turn\r\n\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n      this._makeMove(moves[i])\r\n      if (!this._isKingAttacked(color)) {\r\n        if (depth - 1 > 0) {\r\n          nodes += this.perft(depth - 1)\r\n        } else {\r\n          nodes++\r\n        }\r\n      }\r\n      this._undoMove()\r\n    }\r\n\r\n    return nodes\r\n  }\r\n\r\n  turn(): Color {\r\n    return this._turn\r\n  }\r\n\r\n  board(): ({ square: Square; type: PieceSymbol; color: Color } | null)[][] {\r\n    const output = []\r\n    let row = []\r\n\r\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n      if (this._board[i] == null) {\r\n        row.push(null)\r\n      } else {\r\n        row.push({\r\n          square: algebraic(i),\r\n          type: this._board[i].type,\r\n          color: this._board[i].color,\r\n        })\r\n      }\r\n      if ((i + 1) & 0x88) {\r\n        output.push(row)\r\n        row = []\r\n        i += 8\r\n      }\r\n    }\r\n\r\n    return output\r\n  }\r\n\r\n  squareColor(square: Square): 'light' | 'dark' | null {\r\n    if (square in Ox88) {\r\n      const sq = Ox88[square]\r\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  history(): string[]\r\n  history({ verbose }: { verbose: true }): Move[]\r\n  history({ verbose }: { verbose: false }): string[]\r\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\r\n  history({ verbose = false }: { verbose?: boolean } = {}) {\r\n    const reversedHistory = []\r\n    const moveHistory = []\r\n\r\n    while (this._history.length > 0) {\r\n      reversedHistory.push(this._undoMove())\r\n    }\r\n\r\n    while (true) {\r\n      const move = reversedHistory.pop()\r\n      if (!move) {\r\n        break\r\n      }\r\n\r\n      if (verbose) {\r\n        moveHistory.push(new Move(this, move))\r\n      } else {\r\n        moveHistory.push(this._moveToSan(move, this._moves()))\r\n      }\r\n      this._makeMove(move)\r\n    }\r\n\r\n    return moveHistory\r\n  }\r\n\r\n  /*\r\n   * Keeps track of position occurrence counts for the purpose of repetition\r\n   * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\r\n   * irrelevent information from the fen, initialising new positions, and\r\n   * removing old positions from the record if their counts are reduced to 0.\r\n   */\r\n  private _getPositionCount(fen: string): number {\r\n    const trimmedFen = trimFen(fen)\r\n    return this._positionCount[trimmedFen] || 0\r\n  }\r\n\r\n  private _incPositionCount(fen: string) {\r\n    const trimmedFen = trimFen(fen)\r\n    if (this._positionCount[trimmedFen] === undefined) {\r\n      this._positionCount[trimmedFen] = 0\r\n    }\r\n    this._positionCount[trimmedFen] += 1\r\n  }\r\n\r\n  private _decPositionCount(fen: string) {\r\n    const trimmedFen = trimFen(fen)\r\n    if (this._positionCount[trimmedFen] === 1) {\r\n      delete this._positionCount[trimmedFen]\r\n    } else {\r\n      this._positionCount[trimmedFen] -= 1\r\n    }\r\n  }\r\n\r\n  private _pruneComments() {\r\n    const reversedHistory = []\r\n    const currentComments: Record<string, string> = {}\r\n\r\n    const copyComment = (fen: string) => {\r\n      if (fen in this._comments) {\r\n        currentComments[fen] = this._comments[fen]\r\n      }\r\n    }\r\n\r\n    while (this._history.length > 0) {\r\n      reversedHistory.push(this._undoMove())\r\n    }\r\n\r\n    copyComment(this.fen())\r\n\r\n    while (true) {\r\n      const move = reversedHistory.pop()\r\n      if (!move) {\r\n        break\r\n      }\r\n      this._makeMove(move)\r\n      copyComment(this.fen())\r\n    }\r\n    this._comments = currentComments\r\n  }\r\n\r\n  getComment(): string {\r\n    return this._comments[this.fen()]\r\n  }\r\n\r\n  setComment(comment: string) {\r\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\r\n  }\r\n\r\n  /**\r\n   * @deprecated Renamed to `removeComment` for consistency\r\n   */\r\n  deleteComment(): string {\r\n    return this.removeComment()\r\n  }\r\n\r\n  removeComment(): string {\r\n    const comment = this._comments[this.fen()]\r\n    delete this._comments[this.fen()]\r\n    return comment\r\n  }\r\n\r\n  getComments(): { fen: string; comment: string }[] {\r\n    this._pruneComments()\r\n    return Object.keys(this._comments).map((fen: string) => {\r\n      return { fen: fen, comment: this._comments[fen] }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @deprecated Renamed to `removeComments` for consistency\r\n   */\r\n  deleteComments(): { fen: string; comment: string }[] {\r\n    return this.removeComments()\r\n  }\r\n\r\n  removeComments(): { fen: string; comment: string }[] {\r\n    this._pruneComments()\r\n    return Object.keys(this._comments).map((fen) => {\r\n      const comment = this._comments[fen]\r\n      delete this._comments[fen]\r\n      return { fen: fen, comment: comment }\r\n    })\r\n  }\r\n\r\n  setCastlingRights(\r\n    color: Color,\r\n    rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>,\r\n  ): boolean {\r\n    for (const side of [KING, QUEEN] as const) {\r\n      if (rights[side] !== undefined) {\r\n        if (rights[side]) {\r\n          this._castling[color] |= SIDES[side]\r\n        } else {\r\n          this._castling[color] &= ~SIDES[side]\r\n        }\r\n      }\r\n    }\r\n\r\n    this._updateCastlingRights()\r\n    const result = this.getCastlingRights(color)\r\n\r\n    return (\r\n      (rights[KING] === undefined || rights[KING] === result[KING]) &&\r\n      (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\r\n    )\r\n  }\r\n\r\n  getCastlingRights(color: Color): { [KING]: boolean; [QUEEN]: boolean } {\r\n    return {\r\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\r\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\r\n    }\r\n  }\r\n\r\n  moveNumber(): number {\r\n    return this._moveNumber\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;AA2BO,IAAM,QAAQ;AACd,IAAM,QAAQ;AAEd,IAAM,OAAO;AACb,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,OAAO;AACb,IAAM,QAAQ;AACd,IAAM,OAAO;AAgBb,IAAM,mBACX;AA2BI,IAAO,OAAP,MAAW;EAqBf,YAAY,OAAc,UAAsB;AApBhD;AACA;AACA;AACA;AACA;AACA;AAQA;;;;;;;AAEA;AACA;AACA;AACA;AAGE,UAAM,EAAE,OAAO,OAAO,MAAM,IAAI,OAAO,UAAU,UAAS,IAAK;AAE/D,UAAM,gBAAgB,UAAU,IAAI;AACpC,UAAM,cAAc,UAAU,EAAE;AAEhC,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,OAAO;AACZ,SAAK,KAAK;AAQV,SAAK,MAAM,MAAM,YAAY,EAAE,UAAU,MAAM,QAAQ,EAAE,EAAE,OAAO,KAAI,CAAE,CAAC;AACzE,SAAK,MAAM,gBAAgB;AAC3B,SAAK,SAAS,MAAM,IAAG;AAGvB,UAAM,WAAW,EAAE,QAAQ;AAC3B,SAAK,QAAQ,MAAM,IAAG;AACtB,UAAM,WAAW,EAAC;AAGlB,SAAK,QAAQ;AACb,eAAW,QAAQ,MAAM;AACvB,UAAI,KAAK,IAAI,IAAI,OAAO;AACtB,aAAK,SAAS,MAAM,IAAI;;;AAI5B,QAAI,UAAU;AACZ,WAAK,WAAW;;AAGlB,QAAI,WAAW;AACb,WAAK,YAAY;AACjB,WAAK,OAAO;;EAEhB;EAEA,YAAS;AACP,WAAO,KAAK,MAAM,QAAQ,MAAM,SAAS,CAAC,IAAI;EAChD;EAEA,cAAW;AACT,WAAO,KAAK,MAAM,QAAQ,MAAM,WAAW,CAAC,IAAI;EAClD;EAEA,cAAW;AACT,WAAO,KAAK,MAAM,QAAQ,MAAM,YAAY,CAAC,IAAI;EACnD;EAEA,mBAAgB;AACd,WAAO,KAAK,MAAM,QAAQ,MAAM,cAAc,CAAC,IAAI;EACrD;EAEA,oBAAiB;AACf,WAAO,KAAK,MAAM,QAAQ,MAAM,cAAc,CAAC,IAAI;EACrD;EAEA,YAAS;AACP,WAAO,KAAK,MAAM,QAAQ,MAAM,UAAU,CAAC,IAAI;EACjD;;AAGF,IAAM,QAAQ;AAEd,IAAM,QAAgC;EACpC,QAAQ;EACR,SAAS;EACT,UAAU;EACV,YAAY;EACZ,WAAW;EACX,cAAc;EACd,cAAc;;AAIT,IAAM,UAAoB;EAC/B;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1C;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;;AAG5C,IAAM,OAA+B;EACnC,QAAQ;EACR,SAAS;EACT,UAAU;EACV,YAAY;EACZ,WAAW;EACX,cAAc;EACd,cAAc;;AA4ChB,IAAM,OAA+B;EACnC,IAAM;EAAG,IAAM;EAAG,IAAM;EAAG,IAAM;EAAG,IAAM;EAAG,IAAM;EAAG,IAAM;EAAG,IAAM;EACrE,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EACpE,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EACpE,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EACpE,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EACpE,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EACpE,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAK;EAAI,IAAI;EAAK,IAAI;EAAK,IAAI;EAAK,IAAI;EACnE,IAAI;EAAK,IAAI;EAAK,IAAI;EAAK,IAAI;EAAK,IAAI;EAAK,IAAI;EAAK,IAAI;EAAK,IAAI;;AAGrE,IAAM,eAAe;EACnB,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE;EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG;;AAGxB,IAAM,gBAAgB;EACpB,GAAG,CAAC,KAAK,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,EAAE;EACtC,GAAG,CAAC,KAAK,KAAK,IAAI,EAAE;EACpB,GAAG,CAAC,KAAK,GAAG,IAAI,EAAE;EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI,EAAE;EACpC,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI,EAAE;;AAItC,IAAM,UAAU;EACd;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAC/C;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAC/C;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAAK;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAAK;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAChD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAC/C;EAAG;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAAK;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAAK;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAC/C;EAAG;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAAG;EAC/C;EAAE;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAG;EAAE;EAAI;EAAG;EAChD;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAK;EAAG;EAAG;EAAG;EAAG;EAAG;EAAE;;AAI9C,IAAM,OAAO;EACV;EAAK;EAAI;EAAI;EAAI;EAAI;EAAI;EAAG;EAAK;EAAI;EAAI;EAAI;EAAI;EAAI;EAAG;EAAI;EAC3D;EAAG;EAAK;EAAI;EAAI;EAAI;EAAI;EAAG;EAAK;EAAI;EAAI;EAAI;EAAI;EAAG;EAAK;EAAG;EAC3D;EAAI;EAAG;EAAK;EAAI;EAAI;EAAI;EAAG;EAAK;EAAI;EAAI;EAAI;EAAG;EAAK;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAG;EAAK;EAAI;EAAI;EAAG;EAAK;EAAI;EAAI;EAAG;EAAK;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAI;EAAG;EAAK;EAAI;EAAG;EAAK;EAAI;EAAG;EAAK;EAAI;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAI;EAAI;EAAG;EAAK;EAAG;EAAK;EAAG;EAAK;EAAI;EAAI;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAI;EAAI;EAAI;EAAG;EAAI;EAAI;EAAK;EAAI;EAAI;EAAI;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAI;EAAI;EAAI;EAAI;EAAI;EAAG;EAAI;EAAK;EAAG;EAAI;EAAI;EAAI;EAAI;EAC3D;EAAI;EAAI;EAAI;EAAI;EAAI;EAAE;EAAI;EAAI;EAAM;EAAI;EAAI;EAAI;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAI;EAAI;EAAE;EAAM;EAAE;EAAM;EAAE;EAAM;EAAI;EAAI;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAI;EAAE;EAAM;EAAI;EAAE;EAAM;EAAI;EAAE;EAAM;EAAI;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAI;EAAE;EAAM;EAAI;EAAI;EAAE;EAAM;EAAI;EAAI;EAAE;EAAM;EAAI;EAAI;EAAG;EAC3D;EAAI;EAAE;EAAM;EAAI;EAAI;EAAI;EAAE;EAAM;EAAI;EAAI;EAAI;EAAE;EAAM;EAAI;EAAG;EAC3D;EAAE;EAAM;EAAI;EAAI;EAAI;EAAI;EAAE;EAAM;EAAI;EAAI;EAAI;EAAI;EAAE;EAAM;EAAG;EAC7D;EAAM;EAAI;EAAI;EAAI;EAAI;EAAI;EAAE;EAAM;EAAI;EAAI;EAAI;EAAI;EAAI;EAAE;;AAG1D,IAAM,cAAc,EAAE,GAAG,GAAK,GAAG,GAAK,GAAG,GAAK,GAAG,GAAK,GAAG,IAAM,GAAG,GAAI;AAEtE,IAAM,UAAU;AAEhB,IAAM,aAA4B,CAAC,QAAQ,QAAQ,MAAM,KAAK;AAE9D,IAAM,SAAS;AACf,IAAM,SAAS;AAOf,IAAM,SAAS;AACf,IAAM,SAAS;AAEf,IAAM,QAAQ;EACZ,CAAC,IAAI,GAAG,KAAK;EACb,CAAC,KAAK,GAAG,KAAK;;AAGhB,IAAM,QAAQ;EACZ,GAAG;IACD,EAAE,QAAQ,KAAK,IAAI,MAAM,KAAK,aAAY;IAC1C,EAAE,QAAQ,KAAK,IAAI,MAAM,KAAK,aAAY;;EAE5C,GAAG;IACD,EAAE,QAAQ,KAAK,IAAI,MAAM,KAAK,aAAY;IAC1C,EAAE,QAAQ,KAAK,IAAI,MAAM,KAAK,aAAY;;;AAI9C,IAAM,cAAc,EAAE,GAAG,QAAQ,GAAG,OAAM;AAE1C,IAAM,sBAAsB,CAAC,OAAO,OAAO,WAAW,GAAG;AAGzD,SAAS,KAAK,QAAc;AAC1B,SAAO,UAAU;AACnB;AAGA,SAAS,KAAK,QAAc;AAC1B,SAAO,SAAS;AAClB;AAEA,SAAS,QAAQ,GAAS;AACxB,SAAO,aAAa,QAAQ,CAAC,MAAM;AACrC;AAGA,SAAS,UAAU,QAAc;AAC/B,QAAM,IAAI,KAAK,MAAM;AACrB,QAAM,IAAI,KAAK,MAAM;AACrB,SAAQ,WAAW,UAAU,GAAG,IAAI,CAAC,IACnC,WAAW,UAAU,GAAG,IAAI,CAAC;AACjC;AAEA,SAAS,UAAU,OAAY;AAC7B,SAAO,UAAU,QAAQ,QAAQ;AACnC;AAEM,SAAU,YAAY,KAAW;AAErC,QAAM,SAAS,IAAI,MAAM,KAAK;AAC9B,MAAI,OAAO,WAAW,GAAG;AACvB,WAAO;MACL,IAAI;MACJ,OAAO;;;AAKX,QAAM,aAAa,SAAS,OAAO,CAAC,GAAG,EAAE;AACzC,MAAI,MAAM,UAAU,KAAK,cAAc,GAAG;AACxC,WAAO;MACL,IAAI;MACJ,OAAO;;;AAKX,QAAM,YAAY,SAAS,OAAO,CAAC,GAAG,EAAE;AACxC,MAAI,MAAM,SAAS,KAAK,YAAY,GAAG;AACrC,WAAO;MACL,IAAI;MACJ,OACE;;;AAKN,MAAI,CAAC,uBAAuB,KAAK,OAAO,CAAC,CAAC,GAAG;AAC3C,WAAO,EAAE,IAAI,OAAO,OAAO,4CAA2C;;AAIxE,MAAI,WAAW,KAAK,OAAO,CAAC,CAAC,GAAG;AAC9B,WAAO,EAAE,IAAI,OAAO,OAAO,gDAA+C;;AAI5E,MAAI,CAAC,UAAU,KAAK,OAAO,CAAC,CAAC,GAAG;AAC9B,WAAO,EAAE,IAAI,OAAO,OAAO,uCAAsC;;AAInE,QAAM,OAAO,OAAO,CAAC,EAAE,MAAM,GAAG;AAChC,MAAI,KAAK,WAAW,GAAG;AACrB,WAAO;MACL,IAAI;MACJ,OAAO;;;AAKX,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAEpC,QAAI,YAAY;AAChB,QAAI,oBAAoB;AAExB,aAAS,IAAI,GAAG,IAAI,KAAK,CAAC,EAAE,QAAQ,KAAK;AACvC,UAAI,QAAQ,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG;AACvB,YAAI,mBAAmB;AACrB,iBAAO;YACL,IAAI;YACJ,OAAO;;;AAGX,qBAAa,SAAS,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE;AACpC,4BAAoB;aACf;AACL,YAAI,CAAC,mBAAmB,KAAK,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG;AACxC,iBAAO;YACL,IAAI;YACJ,OAAO;;;AAGX,qBAAa;AACb,4BAAoB;;;AAGxB,QAAI,cAAc,GAAG;AACnB,aAAO;QACL,IAAI;QACJ,OAAO;;;;AAMb,MACG,OAAO,CAAC,EAAE,CAAC,KAAK,OAAO,OAAO,CAAC,KAAK,OACpC,OAAO,CAAC,EAAE,CAAC,KAAK,OAAO,OAAO,CAAC,KAAK,KACrC;AACA,WAAO,EAAE,IAAI,OAAO,OAAO,yCAAwC;;AAIrE,QAAM,QAAQ;IACZ,EAAE,OAAO,SAAS,OAAO,KAAI;IAC7B,EAAE,OAAO,SAAS,OAAO,KAAI;;AAG/B,aAAW,EAAE,OAAO,MAAK,KAAM,OAAO;AACpC,QAAI,CAAC,MAAM,KAAK,OAAO,CAAC,CAAC,GAAG;AAC1B,aAAO,EAAE,IAAI,OAAO,OAAO,wBAAwB,KAAK,QAAO;;AAGjE,SAAK,OAAO,CAAC,EAAE,MAAM,KAAK,KAAK,CAAA,GAAI,SAAS,GAAG;AAC7C,aAAO,EAAE,IAAI,OAAO,OAAO,yBAAyB,KAAK,SAAQ;;;AAKrE,MACE,MAAM,KAAK,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,KAAK,YAAW,MAAO,GAAG,GACvE;AACA,WAAO;MACL,IAAI;MACJ,OAAO;;;AAIX,SAAO,EAAE,IAAI,KAAI;AACnB;AAGA,SAAS,iBAAiB,MAAoB,OAAqB;AACjE,QAAM,OAAO,KAAK;AAClB,QAAM,KAAK,KAAK;AAChB,QAAM,QAAQ,KAAK;AAEnB,MAAI,cAAc;AAClB,MAAI,WAAW;AACf,MAAI,WAAW;AAEf,WAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,UAAM,YAAY,MAAM,CAAC,EAAE;AAC3B,UAAM,UAAU,MAAM,CAAC,EAAE;AACzB,UAAM,aAAa,MAAM,CAAC,EAAE;AAM5B,QAAI,UAAU,cAAc,SAAS,aAAa,OAAO,SAAS;AAChE;AAEA,UAAI,KAAK,IAAI,MAAM,KAAK,SAAS,GAAG;AAClC;;AAGF,UAAI,KAAK,IAAI,MAAM,KAAK,SAAS,GAAG;AAClC;;;;AAKN,MAAI,cAAc,GAAG;AACnB,QAAI,WAAW,KAAK,WAAW,GAAG;AAKhC,aAAO,UAAU,IAAI;eACZ,WAAW,GAAG;AAKvB,aAAO,UAAU,IAAI,EAAE,OAAO,CAAC;WAC1B;AAEL,aAAO,UAAU,IAAI,EAAE,OAAO,CAAC;;;AAInC,SAAO;AACT;AAEA,SAAS,QACP,OACA,OACA,MACA,IACA,OACA,WAAoC,QACpC,QAAgB,KAAK,QAAM;AAE3B,QAAM,IAAI,KAAK,EAAE;AAEjB,MAAI,UAAU,SAAS,MAAM,UAAU,MAAM,SAAS;AACpD,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAM,YAAY,WAAW,CAAC;AAC9B,YAAM,KAAK;QACT;QACA;QACA;QACA;QACA;QACA;QACA,OAAO,QAAQ,KAAK;OACrB;;SAEE;AACL,UAAM,KAAK;MACT;MACA;MACA;MACA;MACA;MACA;KACD;;AAEL;AAEA,SAAS,eAAe,KAAW;AACjC,MAAI,YAAY,IAAI,OAAO,CAAC;AAC5B,MAAI,aAAa,OAAO,aAAa,KAAK;AACxC,UAAM,UAAU,IAAI,MAAM,kBAAkB;AAC5C,QAAI,SAAS;AACX,aAAO;;AAET,WAAO;;AAET,cAAY,UAAU,YAAW;AACjC,MAAI,cAAc,KAAK;AACrB,WAAO;;AAET,SAAO;AACT;AAGA,SAAS,YAAY,MAAY;AAC/B,SAAO,KAAK,QAAQ,KAAK,EAAE,EAAE,QAAQ,eAAe,EAAE;AACxD;AAEA,SAAS,QAAQ,KAAW;AAK1B,SAAO,IAAI,MAAM,GAAG,EAAE,MAAM,GAAG,CAAC,EAAE,KAAK,GAAG;AAC5C;AAEM,IAAO,QAAP,MAAY;EAehB,YAAY,MAAM,kBAAgB;AAd1B,kCAAS,IAAI,MAAa,GAAG;AAC7B,iCAAe;AACf,mCAAkC,CAAA;AAClC,kCAAgC,EAAE,GAAG,OAAO,GAAG,MAAK;AACpD,qCAAY;AACZ,sCAAa;AACb,uCAAc;AACd,oCAAsB,CAAA;AACtB,qCAAoC,CAAA;AACpC,qCAAmC,EAAE,GAAG,GAAG,GAAG,EAAC;AAG/C;0CAAyC,CAAA;AAG/C,SAAK,KAAK,GAAG;EACf;EAEA,MAAM,EAAE,kBAAkB,MAAK,IAAK,CAAA,GAAE;AACpC,SAAK,SAAS,IAAI,MAAa,GAAG;AAClC,SAAK,SAAS,EAAE,GAAG,OAAO,GAAG,MAAK;AAClC,SAAK,QAAQ;AACb,SAAK,YAAY,EAAE,GAAG,GAAG,GAAG,EAAC;AAC7B,SAAK,YAAY;AACjB,SAAK,aAAa;AAClB,SAAK,cAAc;AACnB,SAAK,WAAW,CAAA;AAChB,SAAK,YAAY,CAAA;AACjB,SAAK,UAAU,kBAAkB,KAAK,UAAU,CAAA;AAChD,SAAK,iBAAiB,CAAA;AAOtB,WAAO,KAAK,QAAQ,OAAO;AAC3B,WAAO,KAAK,QAAQ,KAAK;EAC3B;EAEA,KAAK,KAAa,EAAE,iBAAiB,OAAO,kBAAkB,MAAK,IAAK,CAAA,GAAE;AACxE,QAAI,SAAS,IAAI,MAAM,KAAK;AAG5B,QAAI,OAAO,UAAU,KAAK,OAAO,SAAS,GAAG;AAC3C,YAAM,cAAc,CAAC,KAAK,KAAK,KAAK,GAAG;AACvC,YAAM,OAAO,OAAO,YAAY,MAAM,EAAE,IAAI,OAAO,OAAO,CAAC,EAAE,KAAK,GAAG;;AAGvE,aAAS,IAAI,MAAM,KAAK;AAExB,QAAI,CAAC,gBAAgB;AACnB,YAAM,EAAE,IAAI,MAAK,IAAK,YAAY,GAAG;AACrC,UAAI,CAAC,IAAI;AACP,cAAM,IAAI,MAAM,KAAK;;;AAIzB,UAAM,WAAW,OAAO,CAAC;AACzB,QAAI,SAAS;AAEb,SAAK,MAAM,EAAE,gBAAe,CAAE;AAE9B,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,QAAQ,SAAS,OAAO,CAAC;AAE/B,UAAI,UAAU,KAAK;AACjB,kBAAU;iBACD,QAAQ,KAAK,GAAG;AACzB,kBAAU,SAAS,OAAO,EAAE;aACvB;AACL,cAAM,QAAQ,QAAQ,MAAM,QAAQ;AACpC,aAAK,KACH,EAAE,MAAM,MAAM,YAAW,GAAmB,MAAK,GACjD,UAAU,MAAM,CAAC;AAEnB;;;AAIJ,SAAK,QAAQ,OAAO,CAAC;AAErB,QAAI,OAAO,CAAC,EAAE,QAAQ,GAAG,IAAI,IAAI;AAC/B,WAAK,UAAU,KAAK,KAAK;;AAE3B,QAAI,OAAO,CAAC,EAAE,QAAQ,GAAG,IAAI,IAAI;AAC/B,WAAK,UAAU,KAAK,KAAK;;AAE3B,QAAI,OAAO,CAAC,EAAE,QAAQ,GAAG,IAAI,IAAI;AAC/B,WAAK,UAAU,KAAK,KAAK;;AAE3B,QAAI,OAAO,CAAC,EAAE,QAAQ,GAAG,IAAI,IAAI;AAC/B,WAAK,UAAU,KAAK,KAAK;;AAG3B,SAAK,YAAY,OAAO,CAAC,MAAM,MAAM,QAAQ,KAAK,OAAO,CAAC,CAAW;AACrE,SAAK,aAAa,SAAS,OAAO,CAAC,GAAG,EAAE;AACxC,SAAK,cAAc,SAAS,OAAO,CAAC,GAAG,EAAE;AAEzC,SAAK,aAAa,GAAG;AACrB,SAAK,kBAAkB,GAAG;EAC5B;EAEA,MAAG;AA7sBL;AA8sBI,QAAI,QAAQ;AACZ,QAAI,MAAM;AAEV,aAAS,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AACvC,UAAI,KAAK,OAAO,CAAC,GAAG;AAClB,YAAI,QAAQ,GAAG;AACb,iBAAO;AACP,kBAAQ;;AAEV,cAAM,EAAE,OAAO,MAAM,MAAK,IAAK,KAAK,OAAO,CAAC;AAE5C,eAAO,UAAU,QAAQ,MAAM,YAAW,IAAK,MAAM,YAAW;aAC3D;AACL;;AAGF,UAAK,IAAI,IAAK,KAAM;AAClB,YAAI,QAAQ,GAAG;AACb,iBAAO;;AAGT,YAAI,MAAM,KAAK,IAAI;AACjB,iBAAO;;AAGT,gBAAQ;AACR,aAAK;;;AAIT,QAAI,WAAW;AACf,QAAI,KAAK,UAAU,KAAK,IAAI,KAAK,cAAc;AAC7C,kBAAY;;AAEd,QAAI,KAAK,UAAU,KAAK,IAAI,KAAK,cAAc;AAC7C,kBAAY;;AAEd,QAAI,KAAK,UAAU,KAAK,IAAI,KAAK,cAAc;AAC7C,kBAAY;;AAEd,QAAI,KAAK,UAAU,KAAK,IAAI,KAAK,cAAc;AAC7C,kBAAY;;AAId,eAAW,YAAY;AAEvB,QAAI,WAAW;AAKf,QAAI,KAAK,cAAc,OAAO;AAC5B,YAAM,gBAAgB,KAAK,aAAa,KAAK,UAAU,QAAQ,KAAK;AACpE,YAAM,UAAU,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;AAErD,iBAAW,UAAU,SAAS;AAE5B,YAAI,SAAS,KAAM;AACjB;;AAGF,cAAM,QAAQ,KAAK;AAGnB,cACE,UAAK,OAAO,MAAM,MAAlB,mBAAqB,WAAU,WAC/B,UAAK,OAAO,MAAM,MAAlB,mBAAqB,UAAS,MAC9B;AAEA,eAAK,UAAU;YACb;YACA,MAAM;YACN,IAAI,KAAK;YACT,OAAO;YACP,UAAU;YACV,OAAO,KAAK;WACb;AACD,gBAAM,UAAU,CAAC,KAAK,gBAAgB,KAAK;AAC3C,eAAK,UAAS;AAGd,cAAI,SAAS;AACX,uBAAW,UAAU,KAAK,SAAS;AACnC;;;;;AAMR,WAAO;MACL;MACA,KAAK;MACL;MACA;MACA,KAAK;MACL,KAAK;MACL,KAAK,GAAG;EACZ;;;;;;;EAQQ,aAAa,KAAW;AAC9B,QAAI,KAAK,SAAS,SAAS;AAAG;AAE9B,QAAI,QAAQ,kBAAkB;AAC5B,WAAK,QAAQ,OAAO,IAAI;AACxB,WAAK,QAAQ,KAAK,IAAI;WACjB;AACL,aAAO,KAAK,QAAQ,OAAO;AAC3B,aAAO,KAAK,QAAQ,KAAK;;EAE7B;EAEA,QAAK;AACH,SAAK,KAAK,gBAAgB;EAC5B;EAEA,IAAI,QAAc;AAChB,WAAO,KAAK,OAAO,KAAK,MAAM,CAAC;EACjC;EAEA,IACE,EAAE,MAAM,MAAK,GACb,QAAc;AAEd,QAAI,KAAK,KAAK,EAAE,MAAM,MAAK,GAAI,MAAM,GAAG;AACtC,WAAK,sBAAqB;AAC1B,WAAK,uBAAsB;AAC3B,WAAK,aAAa,KAAK,IAAG,CAAE;AAC5B,aAAO;;AAET,WAAO;EACT;EAEQ,KACN,EAAE,MAAM,MAAK,GACb,QAAc;AAGd,QAAI,QAAQ,QAAQ,KAAK,YAAW,CAAE,MAAM,IAAI;AAC9C,aAAO;;AAIT,QAAI,EAAE,UAAU,OAAO;AACrB,aAAO;;AAGT,UAAM,KAAK,KAAK,MAAM;AAGtB,QACE,QAAQ,QACR,EAAE,KAAK,OAAO,KAAK,KAAK,SAAS,KAAK,OAAO,KAAK,KAAK,KACvD;AACA,aAAO;;AAGT,UAAM,uBAAuB,KAAK,OAAO,EAAE;AAG3C,QAAI,wBAAwB,qBAAqB,SAAS,MAAM;AAC9D,WAAK,OAAO,qBAAqB,KAAK,IAAI;;AAG5C,SAAK,OAAO,EAAE,IAAI,EAAE,MAA2B,MAAqB;AAEpE,QAAI,SAAS,MAAM;AACjB,WAAK,OAAO,KAAK,IAAI;;AAGvB,WAAO;EACT;EAEA,OAAO,QAAc;AACnB,UAAM,QAAQ,KAAK,IAAI,MAAM;AAC7B,WAAO,KAAK,OAAO,KAAK,MAAM,CAAC;AAC/B,QAAI,SAAS,MAAM,SAAS,MAAM;AAChC,WAAK,OAAO,MAAM,KAAK,IAAI;;AAG7B,SAAK,sBAAqB;AAC1B,SAAK,uBAAsB;AAC3B,SAAK,aAAa,KAAK,IAAG,CAAE;AAE5B,WAAO;EACT;EAEQ,wBAAqB;AA/4B/B;AAg5BI,UAAM,qBACJ,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,UAAS,UAC/B,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,WAAU;AAClC,UAAM,qBACJ,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,UAAS,UAC/B,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,WAAU;AAElC,QACE,CAAC,sBACD,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,UAAS,UAC/B,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,WAAU,OAChC;AACA,WAAK,UAAU,KAAK,CAAC,KAAK;;AAG5B,QACE,CAAC,sBACD,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,UAAS,UAC/B,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,WAAU,OAChC;AACA,WAAK,UAAU,KAAK,CAAC,KAAK;;AAG5B,QACE,CAAC,sBACD,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,UAAS,UAC/B,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,WAAU,OAChC;AACA,WAAK,UAAU,KAAK,CAAC,KAAK;;AAG5B,QACE,CAAC,sBACD,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,UAAS,UAC/B,UAAK,OAAO,KAAK,EAAE,MAAnB,mBAAsB,WAAU,OAChC;AACA,WAAK,UAAU,KAAK,CAAC,KAAK;;EAE9B;EAEQ,yBAAsB;AAx7BhC;AAy7BI,QAAI,KAAK,cAAc,OAAO;AAC5B;;AAGF,UAAM,cAAc,KAAK,aAAa,KAAK,UAAU,QAAQ,MAAM;AACnE,UAAM,gBAAgB,KAAK,aAAa,KAAK,UAAU,QAAQ,KAAK;AACpE,UAAM,YAAY,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;AAEvD,QACE,KAAK,OAAO,WAAW,MAAM,QAC7B,KAAK,OAAO,KAAK,SAAS,MAAM,UAChC,UAAK,OAAO,aAAa,MAAzB,mBAA4B,WAAU,UAAU,KAAK,KAAK,OAC1D,UAAK,OAAO,aAAa,MAAzB,mBAA4B,UAAS,MACrC;AACA,WAAK,YAAY;AACjB;;AAGF,UAAM,aAAa,CAAC,WAAgB;AA38BxC,UAAAA,KAAAC;AA48BM,eAAE,SAAS,UACXD,MAAA,KAAK,OAAO,MAAM,MAAlB,gBAAAA,IAAqB,WAAU,KAAK,WACpCC,MAAA,KAAK,OAAO,MAAM,MAAlB,gBAAAA,IAAqB,UAAS;;AAEhC,QAAI,CAAC,UAAU,KAAK,UAAU,GAAG;AAC/B,WAAK,YAAY;;EAErB;EAKQ,UAAU,OAAc,QAAgB,SAAiB;AAC/D,UAAM,YAAsB,CAAA;AAC5B,aAAS,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AAEvC,UAAI,IAAI,KAAM;AACZ,aAAK;AACL;;AAIF,UAAI,KAAK,OAAO,CAAC,MAAM,UAAa,KAAK,OAAO,CAAC,EAAE,UAAU,OAAO;AAClE;;AAGF,YAAM,QAAQ,KAAK,OAAO,CAAC;AAC3B,YAAM,aAAa,IAAI;AAGvB,UAAI,eAAe,GAAG;AACpB;;AAGF,YAAM,QAAQ,aAAa;AAE3B,UAAI,QAAQ,KAAK,IAAI,YAAY,MAAM,IAAI,GAAG;AAC5C,YAAI,MAAM,SAAS,MAAM;AACvB,cACG,aAAa,KAAK,MAAM,UAAU,SAClC,cAAc,KAAK,MAAM,UAAU,OACpC;AACA,gBAAI,CAAC,SAAS;AACZ,qBAAO;mBACF;AACL,wBAAU,KAAK,UAAU,CAAC,CAAC;;;AAG/B;;AAIF,YAAI,MAAM,SAAS,OAAO,MAAM,SAAS,KAAK;AAC5C,cAAI,CAAC,SAAS;AACZ,mBAAO;iBACF;AACL,sBAAU,KAAK,UAAU,CAAC,CAAC;AAC3B;;;AAIJ,cAAM,SAAS,KAAK,KAAK;AACzB,YAAI,IAAI,IAAI;AAEZ,YAAI,UAAU;AACd,eAAO,MAAM,QAAQ;AACnB,cAAI,KAAK,OAAO,CAAC,KAAK,MAAM;AAC1B,sBAAU;AACV;;AAEF,eAAK;;AAGP,YAAI,CAAC,SAAS;AACZ,cAAI,CAAC,SAAS;AACZ,mBAAO;iBACF;AACL,sBAAU,KAAK,UAAU,CAAC,CAAC;AAC3B;;;;;AAMR,QAAI,SAAS;AACX,aAAO;WACF;AACL,aAAO;;EAEX;EAEA,UAAU,QAAgB,YAAkB;AAC1C,QAAI,CAAC,YAAY;AACf,aAAO,KAAK,UAAU,KAAK,OAAO,KAAK,MAAM,GAAG,IAAI;WAC/C;AACL,aAAO,KAAK,UAAU,YAAY,KAAK,MAAM,GAAG,IAAI;;EAExD;EAEQ,gBAAgB,OAAY;AAClC,UAAM,SAAS,KAAK,OAAO,KAAK;AAChC,WAAO,WAAW,KAAK,QAAQ,KAAK,UAAU,UAAU,KAAK,GAAG,MAAM;EACxE;EAEA,WAAW,QAAgB,YAAiB;AAC1C,WAAO,KAAK,UAAU,YAAY,KAAK,MAAM,CAAC;EAChD;EAEA,UAAO;AACL,WAAO,KAAK,gBAAgB,KAAK,KAAK;EACxC;EAEA,UAAO;AACL,WAAO,KAAK,QAAO;EACrB;EAEA,cAAW;AACT,WAAO,KAAK,QAAO,KAAM,KAAK,OAAM,EAAG,WAAW;EACpD;EAEA,cAAW;AACT,WAAO,CAAC,KAAK,QAAO,KAAM,KAAK,OAAM,EAAG,WAAW;EACrD;EAEA,yBAAsB;AAQpB,UAAM,SAAsC;MAC1C,GAAG;MACH,GAAG;MACH,GAAG;MACH,GAAG;MACH,GAAG;MACH,GAAG;;AAEL,UAAM,UAAU,CAAA;AAChB,QAAI,YAAY;AAChB,QAAI,cAAc;AAElB,aAAS,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AACvC,qBAAe,cAAc,KAAK;AAClC,UAAI,IAAI,KAAM;AACZ,aAAK;AACL;;AAGF,YAAM,QAAQ,KAAK,OAAO,CAAC;AAC3B,UAAI,OAAO;AACT,eAAO,MAAM,IAAI,IAAI,MAAM,QAAQ,SAAS,OAAO,MAAM,IAAI,IAAI,IAAI;AACrE,YAAI,MAAM,SAAS,QAAQ;AACzB,kBAAQ,KAAK,WAAW;;AAE1B;;;AAKJ,QAAI,cAAc,GAAG;AACnB,aAAO;;;MAGP,cAAc,MACb,OAAO,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM;MAC5C;AACA,aAAO;eACE,cAAc,OAAO,MAAM,IAAI,GAAG;AAE3C,UAAI,MAAM;AACV,YAAM,MAAM,QAAQ;AACpB,eAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,eAAO,QAAQ,CAAC;;AAElB,UAAI,QAAQ,KAAK,QAAQ,KAAK;AAC5B,eAAO;;;AAIX,WAAO;EACT;EAEA,wBAAqB;AACnB,WAAO,KAAK,kBAAkB,KAAK,IAAG,CAAE,KAAK;EAC/C;EAEA,qBAAkB;AAChB,WAAO,KAAK,cAAc;EAC5B;EAEA,SAAM;AACJ,WACE,KAAK,mBAAkB,KACvB,KAAK,YAAW,KAChB,KAAK,uBAAsB,KAC3B,KAAK,sBAAqB;EAE9B;EAEA,aAAU;AACR,WAAO,KAAK,YAAW,KAAM,KAAK,YAAW,KAAM,KAAK,OAAM;EAChE;EA0DA,MAAM,EACJ,UAAU,OACV,SAAS,QACT,QAAQ,OAAS,IAC8C,CAAA,GAAE;AACjE,UAAM,QAAQ,KAAK,OAAO,EAAE,QAAQ,MAAK,CAAE;AAE3C,QAAI,SAAS;AACX,aAAO,MAAM,IAAI,CAAC,SAAS,IAAI,KAAK,MAAM,IAAI,CAAC;WAC1C;AACL,aAAO,MAAM,IAAI,CAAC,SAAS,KAAK,WAAW,MAAM,KAAK,CAAC;;EAE3D;EAEQ,OAAO,EACb,QAAQ,MACR,QAAQ,QACR,SAAS,OAAS,IAKhB,CAAA,GAAE;AAxuCR;AAyuCI,UAAM,YAAY,SAAU,OAAO,YAAW,IAAgB;AAC9D,UAAM,WAAW,+BAAO;AAExB,UAAM,QAAwB,CAAA;AAC9B,UAAM,KAAK,KAAK;AAChB,UAAM,OAAO,UAAU,EAAE;AAEzB,QAAI,cAAc,KAAK;AACvB,QAAI,aAAa,KAAK;AACtB,QAAI,eAAe;AAGnB,QAAI,WAAW;AAEb,UAAI,EAAE,aAAa,OAAO;AACxB,eAAO,CAAA;aACF;AACL,sBAAc,aAAa,KAAK,SAAS;AACzC,uBAAe;;;AAInB,aAAS,OAAO,aAAa,QAAQ,YAAY,QAAQ;AAEvD,UAAI,OAAO,KAAM;AACf,gBAAQ;AACR;;AAIF,UAAI,CAAC,KAAK,OAAO,IAAI,KAAK,KAAK,OAAO,IAAI,EAAE,UAAU,MAAM;AAC1D;;AAEF,YAAM,EAAE,KAAI,IAAK,KAAK,OAAO,IAAI;AAEjC,UAAI;AACJ,UAAI,SAAS,MAAM;AACjB,YAAI,YAAY,aAAa;AAAM;AAGnC,aAAK,OAAO,aAAa,EAAE,EAAE,CAAC;AAC9B,YAAI,CAAC,KAAK,OAAO,EAAE,GAAG;AACpB,kBAAQ,OAAO,IAAI,MAAM,IAAI,IAAI;AAGjC,eAAK,OAAO,aAAa,EAAE,EAAE,CAAC;AAC9B,cAAI,YAAY,EAAE,MAAM,KAAK,IAAI,KAAK,CAAC,KAAK,OAAO,EAAE,GAAG;AACtD,oBAAQ,OAAO,IAAI,MAAM,IAAI,MAAM,QAAW,KAAK,QAAQ;;;AAK/D,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,eAAK,OAAO,aAAa,EAAE,EAAE,CAAC;AAC9B,cAAI,KAAK;AAAM;AAEf,gBAAI,UAAK,OAAO,EAAE,MAAd,mBAAiB,WAAU,MAAM;AACnC,oBACE,OACA,IACA,MACA,IACA,MACA,KAAK,OAAO,EAAE,EAAE,MAChB,KAAK,OAAO;qBAEL,OAAO,KAAK,WAAW;AAChC,oBAAQ,OAAO,IAAI,MAAM,IAAI,MAAM,MAAM,KAAK,UAAU;;;aAGvD;AACL,YAAI,YAAY,aAAa;AAAM;AAEnC,iBAAS,IAAI,GAAG,MAAM,cAAc,IAAI,EAAE,QAAQ,IAAI,KAAK,KAAK;AAC9D,gBAAM,SAAS,cAAc,IAAI,EAAE,CAAC;AACpC,eAAK;AAEL,iBAAO,MAAM;AACX,kBAAM;AACN,gBAAI,KAAK;AAAM;AAEf,gBAAI,CAAC,KAAK,OAAO,EAAE,GAAG;AACpB,sBAAQ,OAAO,IAAI,MAAM,IAAI,IAAI;mBAC5B;AAEL,kBAAI,KAAK,OAAO,EAAE,EAAE,UAAU;AAAI;AAElC,sBACE,OACA,IACA,MACA,IACA,MACA,KAAK,OAAO,EAAE,EAAE,MAChB,KAAK,OAAO;AAEd;;AAIF,gBAAI,SAAS,UAAU,SAAS;AAAM;;;;;AAY9C,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,UAAI,CAAC,gBAAgB,eAAe,KAAK,OAAO,EAAE,GAAG;AAEnD,YAAI,KAAK,UAAU,EAAE,IAAI,KAAK,cAAc;AAC1C,gBAAM,eAAe,KAAK,OAAO,EAAE;AACnC,gBAAM,aAAa,eAAe;AAElC,cACE,CAAC,KAAK,OAAO,eAAe,CAAC,KAC7B,CAAC,KAAK,OAAO,UAAU,KACvB,CAAC,KAAK,UAAU,MAAM,KAAK,OAAO,EAAE,CAAC,KACrC,CAAC,KAAK,UAAU,MAAM,eAAe,CAAC,KACtC,CAAC,KAAK,UAAU,MAAM,UAAU,GAChC;AACA,oBACE,OACA,IACA,KAAK,OAAO,EAAE,GACd,YACA,MACA,QACA,KAAK,YAAY;;;AAMvB,YAAI,KAAK,UAAU,EAAE,IAAI,KAAK,cAAc;AAC1C,gBAAM,eAAe,KAAK,OAAO,EAAE;AACnC,gBAAM,aAAa,eAAe;AAElC,cACE,CAAC,KAAK,OAAO,eAAe,CAAC,KAC7B,CAAC,KAAK,OAAO,eAAe,CAAC,KAC7B,CAAC,KAAK,OAAO,eAAe,CAAC,KAC7B,CAAC,KAAK,UAAU,MAAM,KAAK,OAAO,EAAE,CAAC,KACrC,CAAC,KAAK,UAAU,MAAM,eAAe,CAAC,KACtC,CAAC,KAAK,UAAU,MAAM,UAAU,GAChC;AACA,oBACE,OACA,IACA,KAAK,OAAO,EAAE,GACd,YACA,MACA,QACA,KAAK,YAAY;;;;;AAW3B,QAAI,CAAC,SAAS,KAAK,OAAO,EAAE,MAAM,IAAI;AACpC,aAAO;;AAIT,UAAM,aAAa,CAAA;AAEnB,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,WAAK,UAAU,MAAM,CAAC,CAAC;AACvB,UAAI,CAAC,KAAK,gBAAgB,EAAE,GAAG;AAC7B,mBAAW,KAAK,MAAM,CAAC,CAAC;;AAE1B,WAAK,UAAS;;AAGhB,WAAO;EACT;EAEA,KACE,MACA,EAAE,SAAS,MAAK,IAA2B,CAAA,GAAE;AAgB7C,QAAI,UAAU;AAEd,QAAI,OAAO,SAAS,UAAU;AAC5B,gBAAU,KAAK,aAAa,MAAM,MAAM;eAC/B,OAAO,SAAS,UAAU;AACnC,YAAM,QAAQ,KAAK,OAAM;AAGzB,eAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,YACE,KAAK,SAAS,UAAU,MAAM,CAAC,EAAE,IAAI,KACrC,KAAK,OAAO,UAAU,MAAM,CAAC,EAAE,EAAE,MAChC,EAAE,eAAe,MAAM,CAAC,MAAM,KAAK,cAAc,MAAM,CAAC,EAAE,YAC3D;AACA,oBAAU,MAAM,CAAC;AACjB;;;;AAMN,QAAI,CAAC,SAAS;AACZ,UAAI,OAAO,SAAS,UAAU;AAC5B,cAAM,IAAI,MAAM,iBAAiB,IAAI,EAAE;aAClC;AACL,cAAM,IAAI,MAAM,iBAAiB,KAAK,UAAU,IAAI,CAAC,EAAE;;;AAQ3D,UAAM,aAAa,IAAI,KAAK,MAAM,OAAO;AAEzC,SAAK,UAAU,OAAO;AACtB,SAAK,kBAAkB,WAAW,KAAK;AACvC,WAAO;EACT;EAEQ,MAAM,MAAkB;AAC9B,SAAK,SAAS,KAAK;MACjB;MACA,OAAO,EAAE,GAAG,KAAK,OAAO,GAAG,GAAG,KAAK,OAAO,EAAC;MAC3C,MAAM,KAAK;MACX,UAAU,EAAE,GAAG,KAAK,UAAU,GAAG,GAAG,KAAK,UAAU,EAAC;MACpD,UAAU,KAAK;MACf,WAAW,KAAK;MAChB,YAAY,KAAK;KAClB;EACH;EAEQ,UAAU,MAAkB;AAClC,UAAM,KAAK,KAAK;AAChB,UAAM,OAAO,UAAU,EAAE;AACzB,SAAK,MAAM,IAAI;AAEf,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,OAAO,KAAK,IAAI;AAC5C,WAAO,KAAK,OAAO,KAAK,IAAI;AAG5B,QAAI,KAAK,QAAQ,KAAK,YAAY;AAChC,UAAI,KAAK,UAAU,OAAO;AACxB,eAAO,KAAK,OAAO,KAAK,KAAK,EAAE;aAC1B;AACL,eAAO,KAAK,OAAO,KAAK,KAAK,EAAE;;;AAKnC,QAAI,KAAK,WAAW;AAClB,WAAK,OAAO,KAAK,EAAE,IAAI,EAAE,MAAM,KAAK,WAAW,OAAO,GAAE;;AAI1D,QAAI,KAAK,OAAO,KAAK,EAAE,EAAE,SAAS,MAAM;AACtC,WAAK,OAAO,EAAE,IAAI,KAAK;AAGvB,UAAI,KAAK,QAAQ,KAAK,cAAc;AAClC,cAAM,aAAa,KAAK,KAAK;AAC7B,cAAM,eAAe,KAAK,KAAK;AAC/B,aAAK,OAAO,UAAU,IAAI,KAAK,OAAO,YAAY;AAClD,eAAO,KAAK,OAAO,YAAY;iBACtB,KAAK,QAAQ,KAAK,cAAc;AACzC,cAAM,aAAa,KAAK,KAAK;AAC7B,cAAM,eAAe,KAAK,KAAK;AAC/B,aAAK,OAAO,UAAU,IAAI,KAAK,OAAO,YAAY;AAClD,eAAO,KAAK,OAAO,YAAY;;AAIjC,WAAK,UAAU,EAAE,IAAI;;AAIvB,QAAI,KAAK,UAAU,EAAE,GAAG;AACtB,eAAS,IAAI,GAAG,MAAM,MAAM,EAAE,EAAE,QAAQ,IAAI,KAAK,KAAK;AACpD,YACE,KAAK,SAAS,MAAM,EAAE,EAAE,CAAC,EAAE,UAC3B,KAAK,UAAU,EAAE,IAAI,MAAM,EAAE,EAAE,CAAC,EAAE,MAClC;AACA,eAAK,UAAU,EAAE,KAAK,MAAM,EAAE,EAAE,CAAC,EAAE;AACnC;;;;AAMN,QAAI,KAAK,UAAU,IAAI,GAAG;AACxB,eAAS,IAAI,GAAG,MAAM,MAAM,IAAI,EAAE,QAAQ,IAAI,KAAK,KAAK;AACtD,YACE,KAAK,OAAO,MAAM,IAAI,EAAE,CAAC,EAAE,UAC3B,KAAK,UAAU,IAAI,IAAI,MAAM,IAAI,EAAE,CAAC,EAAE,MACtC;AACA,eAAK,UAAU,IAAI,KAAK,MAAM,IAAI,EAAE,CAAC,EAAE;AACvC;;;;AAMN,QAAI,KAAK,QAAQ,KAAK,UAAU;AAC9B,UAAI,OAAO,OAAO;AAChB,aAAK,YAAY,KAAK,KAAK;aACtB;AACL,aAAK,YAAY,KAAK,KAAK;;WAExB;AACL,WAAK,YAAY;;AAInB,QAAI,KAAK,UAAU,MAAM;AACvB,WAAK,aAAa;eACT,KAAK,SAAS,KAAK,UAAU,KAAK,aAAa;AACxD,WAAK,aAAa;WACb;AACL,WAAK;;AAGP,QAAI,OAAO,OAAO;AAChB,WAAK;;AAGP,SAAK,QAAQ;EACf;EAEA,OAAI;AACF,UAAM,OAAO,KAAK,UAAS;AAC3B,QAAI,MAAM;AACR,YAAM,aAAa,IAAI,KAAK,MAAM,IAAI;AACtC,WAAK,kBAAkB,WAAW,KAAK;AACvC,aAAO;;AAET,WAAO;EACT;EAEQ,YAAS;AACf,UAAM,MAAM,KAAK,SAAS,IAAG;AAC7B,QAAI,QAAQ,QAAW;AACrB,aAAO;;AAGT,UAAM,OAAO,IAAI;AAEjB,SAAK,SAAS,IAAI;AAClB,SAAK,QAAQ,IAAI;AACjB,SAAK,YAAY,IAAI;AACrB,SAAK,YAAY,IAAI;AACrB,SAAK,aAAa,IAAI;AACtB,SAAK,cAAc,IAAI;AAEvB,UAAM,KAAK,KAAK;AAChB,UAAM,OAAO,UAAU,EAAE;AAEzB,SAAK,OAAO,KAAK,IAAI,IAAI,KAAK,OAAO,KAAK,EAAE;AAC5C,SAAK,OAAO,KAAK,IAAI,EAAE,OAAO,KAAK;AACnC,WAAO,KAAK,OAAO,KAAK,EAAE;AAE1B,QAAI,KAAK,UAAU;AACjB,UAAI,KAAK,QAAQ,KAAK,YAAY;AAEhC,YAAI;AACJ,YAAI,OAAO,OAAO;AAChB,kBAAQ,KAAK,KAAK;eACb;AACL,kBAAQ,KAAK,KAAK;;AAEpB,aAAK,OAAO,KAAK,IAAI,EAAE,MAAM,MAAM,OAAO,KAAI;aACzC;AAEL,aAAK,OAAO,KAAK,EAAE,IAAI,EAAE,MAAM,KAAK,UAAU,OAAO,KAAI;;;AAI7D,QAAI,KAAK,SAAS,KAAK,eAAe,KAAK,eAAe;AACxD,UAAI,YAAoB;AACxB,UAAI,KAAK,QAAQ,KAAK,cAAc;AAClC,qBAAa,KAAK,KAAK;AACvB,uBAAe,KAAK,KAAK;aACpB;AACL,qBAAa,KAAK,KAAK;AACvB,uBAAe,KAAK,KAAK;;AAG3B,WAAK,OAAO,UAAU,IAAI,KAAK,OAAO,YAAY;AAClD,aAAO,KAAK,OAAO,YAAY;;AAGjC,WAAO;EACT;EAEA,IAAI,EACF,UAAU,MACV,WAAW,EAAC,IAC+B,CAAA,GAAE;AAM7C,UAAM,SAAmB,CAAA;AACzB,QAAI,eAAe;AAGnB,eAAW,KAAK,KAAK,SAAS;AAK5B,aAAO,KAAK,MAAM,IAAI,OAAO,KAAK,QAAQ,CAAC,IAAI,OAAO,OAAO;AAC7D,qBAAe;;AAGjB,QAAI,gBAAgB,KAAK,SAAS,QAAQ;AACxC,aAAO,KAAK,OAAO;;AAGrB,UAAM,gBAAgB,CAACC,gBAAsB;AAC3C,YAAM,UAAU,KAAK,UAAU,KAAK,IAAG,CAAE;AACzC,UAAI,OAAO,YAAY,aAAa;AAClC,cAAM,YAAYA,YAAW,SAAS,IAAI,MAAM;AAChD,QAAAA,cAAa,GAAGA,WAAU,GAAG,SAAS,IAAI,OAAO;;AAEnD,aAAOA;IACT;AAGA,UAAM,kBAAkB,CAAA;AACxB,WAAO,KAAK,SAAS,SAAS,GAAG;AAC/B,sBAAgB,KAAK,KAAK,UAAS,CAAE;;AAGvC,UAAM,QAAQ,CAAA;AACd,QAAI,aAAa;AAGjB,QAAI,gBAAgB,WAAW,GAAG;AAChC,YAAM,KAAK,cAAc,EAAE,CAAC;;AAI9B,WAAO,gBAAgB,SAAS,GAAG;AACjC,mBAAa,cAAc,UAAU;AACrC,YAAM,OAAO,gBAAgB,IAAG;AAGhC,UAAI,CAAC,MAAM;AACT;;AAIF,UAAI,CAAC,KAAK,SAAS,UAAU,KAAK,UAAU,KAAK;AAC/C,cAAM,SAAS,GAAG,KAAK,WAAW;AAElC,qBAAa,aAAa,GAAG,UAAU,IAAI,MAAM,KAAK;iBAC7C,KAAK,UAAU,KAAK;AAE7B,YAAI,WAAW,QAAQ;AACrB,gBAAM,KAAK,UAAU;;AAEvB,qBAAa,KAAK,cAAc;;AAGlC,mBACE,aAAa,MAAM,KAAK,WAAW,MAAM,KAAK,OAAO,EAAE,OAAO,KAAI,CAAE,CAAC;AACvE,WAAK,UAAU,IAAI;;AAIrB,QAAI,WAAW,QAAQ;AACrB,YAAM,KAAK,cAAc,UAAU,CAAC;;AAItC,QAAI,OAAO,KAAK,QAAQ,WAAW,aAAa;AAC9C,YAAM,KAAK,KAAK,QAAQ,MAAM;;AAOhC,QAAI,aAAa,GAAG;AAClB,aAAO,OAAO,KAAK,EAAE,IAAI,MAAM,KAAK,GAAG;;AAIzC,UAAM,QAAQ,WAAA;AACZ,UAAI,OAAO,SAAS,KAAK,OAAO,OAAO,SAAS,CAAC,MAAM,KAAK;AAC1D,eAAO,IAAG;AACV,eAAO;;AAET,aAAO;IACT;AAGA,UAAM,cAAc,SAAU,OAAe,MAAY;AACvD,iBAAW,SAAS,KAAK,MAAM,GAAG,GAAG;AACnC,YAAI,CAAC,OAAO;AACV;;AAEF,YAAI,QAAQ,MAAM,SAAS,UAAU;AACnC,iBAAO,MAAK,GAAI;AACd;;AAEF,iBAAO,KAAK,OAAO;AACnB,kBAAQ;;AAEV,eAAO,KAAK,KAAK;AACjB,iBAAS,MAAM;AACf,eAAO,KAAK,GAAG;AACf;;AAEF,UAAI,MAAK,GAAI;AACX;;AAEF,aAAO;IACT;AAGA,QAAI,eAAe;AACnB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAI,eAAe,MAAM,CAAC,EAAE,SAAS,UAAU;AAC7C,YAAI,MAAM,CAAC,EAAE,SAAS,GAAG,GAAG;AAC1B,yBAAe,YAAY,cAAc,MAAM,CAAC,CAAC;AACjD;;;AAIJ,UAAI,eAAe,MAAM,CAAC,EAAE,SAAS,YAAY,MAAM,GAAG;AAExD,YAAI,OAAO,OAAO,SAAS,CAAC,MAAM,KAAK;AACrC,iBAAO,IAAG;;AAGZ,eAAO,KAAK,OAAO;AACnB,uBAAe;iBACN,MAAM,GAAG;AAClB,eAAO,KAAK,GAAG;AACf;;AAEF,aAAO,KAAK,MAAM,CAAC,CAAC;AACpB,sBAAgB,MAAM,CAAC,EAAE;;AAG3B,WAAO,OAAO,KAAK,EAAE;EACvB;;;;EAKA,UAAU,MAAc;AACtB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACvC,UAAI,OAAO,KAAK,CAAC,MAAM,YAAY,OAAO,KAAK,IAAI,CAAC,MAAM,UAAU;AAClE,aAAK,QAAQ,KAAK,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC;;;AAGtC,WAAO,KAAK;EACd;EAEA,UAAU,KAAa,OAAa;AAClC,SAAK,QAAQ,GAAG,IAAI;AACpB,WAAO,KAAK;EACd;EAEA,aAAa,KAAW;AACtB,QAAI,OAAO,KAAK,SAAS;AACvB,aAAO,KAAK,QAAQ,GAAG;AACvB,aAAO;;AAET,WAAO;EACT;EAEA,aAAU;AACR,WAAO,KAAK;EACd;EAEA,QACE,KACA,EACE,SAAS,OACT,cAAc,QAAO,IACyB,CAAA,GAAE;AAElD,aAAS,KAAK,KAAW;AACvB,aAAO,IAAI,QAAQ,OAAO,IAAI;IAChC;AAEA,aAAS,eAAe,QAAc;AACpC,YAAM,YAAoC,CAAA;AAC1C,YAAMC,WAAU,OAAO,MAAM,IAAI,OAAO,KAAK,WAAW,CAAC,CAAC;AAC1D,UAAI,MAAM;AACV,UAAI,QAAQ;AAEZ,eAAS,IAAI,GAAG,IAAIA,SAAQ,QAAQ,KAAK;AACvC,cAAM,QAAQ;AACd,cAAMA,SAAQ,CAAC,EAAE,QAAQ,OAAO,IAAI;AACpC,gBAAQA,SAAQ,CAAC,EAAE,QAAQ,OAAO,IAAI;AACtC,YAAI,IAAI,KAAI,EAAG,SAAS,GAAG;AACzB,oBAAU,GAAG,IAAI;;;AAIrB,aAAO;IACT;AAGA,UAAM,IAAI,KAAI;AAWd,UAAM,cAAc,IAAI,OACtB,cACE,KAAK,WAAW,IAChB,sBAEA,KAAK,WAAW,IAChB,iBACA,KAAK,WAAW,IAChB,MAAM;AAIV,UAAM,qBAAqB,YAAY,KAAK,GAAG;AAC/C,UAAM,eAAe,qBACjB,mBAAmB,UAAU,IAC3B,mBAAmB,CAAC,IACpB,KACF;AAGJ,SAAK,MAAK;AAGV,UAAM,UAAU,eAAe,YAAY;AAC3C,QAAI,MAAM;AAEV,eAAW,OAAO,SAAS;AAEzB,UAAI,IAAI,YAAW,MAAO,OAAO;AAC/B,cAAM,QAAQ,GAAG;;AAGnB,WAAK,OAAO,KAAK,QAAQ,GAAG,CAAC;;AAO/B,QAAI,CAAC,QAAQ;AACX,UAAI,KAAK;AACP,aAAK,KAAK,KAAK,EAAE,iBAAiB,KAAI,CAAE;;WAErC;AAKL,UAAI,QAAQ,OAAO,MAAM,KAAK;AAC5B,YAAI,EAAE,SAAS,UAAU;AACvB,gBAAM,IAAI,MACR,sDAAsD;;AAI1D,aAAK,KAAK,QAAQ,KAAK,GAAG,EAAE,iBAAiB,KAAI,CAAE;;;AAevD,aAAS,MAAM,GAAS;AACtB,aAAO,MAAM,KAAK,CAAC,EAChB,IAAI,SAAU,GAAC;AAKd,eAAO,EAAE,WAAW,CAAC,IAAI,MACrB,EAAE,WAAW,CAAC,EAAE,SAAS,EAAE,IAC3B,mBAAmB,CAAC,EAAE,QAAQ,MAAM,EAAE,EAAE,YAAW;MACzD,CAAC,EACA,KAAK,EAAE;IACZ;AAEA,aAAS,QAAQ,GAAS;AACxB,aAAO,EAAE,UAAU,IACf,KACA,mBAAmB,OAAO,EAAE,MAAM,SAAS,KAAK,CAAA,GAAI,KAAK,GAAG,CAAC;IACnE;AAEA,UAAM,gBAAgB,SAAU,GAAS;AACvC,UAAI,EAAE,QAAQ,IAAI,OAAO,KAAK,WAAW,GAAG,GAAG,GAAG,GAAG;AACrD,aAAO,IAAI,MAAM,EAAE,MAAM,GAAG,EAAE,SAAS,CAAC,CAAC,CAAC;IAC5C;AAEA,UAAM,gBAAgB,SAAU,GAAS;AACvC,UAAI,EAAE,WAAW,GAAG,KAAK,EAAE,SAAS,GAAG,GAAG;AACxC,eAAO,QAAQ,EAAE,MAAM,GAAG,EAAE,SAAS,CAAC,CAAC;;IAE3C;AAGA,QAAI,KAAK,IACN,QAAQ,cAAc,EAAE,EACxB;;MAEC,IAAI,OAAO,mBAAmB,KAAK,WAAW,CAAC,OAAO,GAAG;MACzD,SAAU,QAAQ,SAAS,WAAS;AAClC,eAAO,YAAY,SACf,cAAc,OAAO,IACrB,MAAM,cAAc,IAAI,UAAU,MAAM,CAAC,CAAC,GAAG;MACnD;IAAC,EAEF,QAAQ,IAAI,OAAO,KAAK,WAAW,GAAG,GAAG,GAAG,GAAG;AAGlD,UAAM,WAAW;AACjB,WAAO,SAAS,KAAK,EAAE,GAAG;AACxB,WAAK,GAAG,QAAQ,UAAU,EAAE;;AAI9B,SAAK,GAAG,QAAQ,iBAAiB,EAAE;AAGnC,SAAK,GAAG,QAAQ,WAAW,EAAE;AAG7B,SAAK,GAAG,QAAQ,UAAU,EAAE;AAG5B,QAAI,QAAQ,GAAG,KAAI,EAAG,MAAM,IAAI,OAAO,KAAK,CAAC;AAG7C,YAAQ,MAAM,OAAO,CAAC,SAAS,SAAS,EAAE;AAE1C,QAAI,SAAS;AAEb,aAAS,WAAW,GAAG,WAAW,MAAM,QAAQ,YAAY;AAC1D,YAAM,UAAU,cAAc,MAAM,QAAQ,CAAC;AAC7C,UAAI,YAAY,QAAW;AACzB,aAAK,UAAU,KAAK,IAAG,CAAE,IAAI;AAC7B;;AAGF,YAAM,OAAO,KAAK,aAAa,MAAM,QAAQ,GAAG,MAAM;AAGtD,UAAI,QAAQ,MAAM;AAEhB,YAAI,oBAAoB,QAAQ,MAAM,QAAQ,CAAC,IAAI,IAAI;AACrD,mBAAS,MAAM,QAAQ;eAClB;AACL,gBAAM,IAAI,MAAM,wBAAwB,MAAM,QAAQ,CAAC,EAAE;;aAEtD;AAEL,iBAAS;AACT,aAAK,UAAU,IAAI;AACnB,aAAK,kBAAkB,KAAK,IAAG,CAAE;;;AAUrC,QAAI,UAAU,OAAO,KAAK,KAAK,OAAO,EAAE,UAAU,CAAC,KAAK,QAAQ,QAAQ,GAAG;AACzE,WAAK,OAAO,UAAU,MAAM;;EAEhC;;;;;;;;;;;;EAcQ,WAAW,MAAoB,OAAqB;AAC1D,QAAI,SAAS;AAEb,QAAI,KAAK,QAAQ,KAAK,cAAc;AAClC,eAAS;eACA,KAAK,QAAQ,KAAK,cAAc;AACzC,eAAS;WACJ;AACL,UAAI,KAAK,UAAU,MAAM;AACvB,cAAM,gBAAgB,iBAAiB,MAAM,KAAK;AAClD,kBAAU,KAAK,MAAM,YAAW,IAAK;;AAGvC,UAAI,KAAK,SAAS,KAAK,UAAU,KAAK,aAAa;AACjD,YAAI,KAAK,UAAU,MAAM;AACvB,oBAAU,UAAU,KAAK,IAAI,EAAE,CAAC;;AAElC,kBAAU;;AAGZ,gBAAU,UAAU,KAAK,EAAE;AAE3B,UAAI,KAAK,WAAW;AAClB,kBAAU,MAAM,KAAK,UAAU,YAAW;;;AAI9C,SAAK,UAAU,IAAI;AACnB,QAAI,KAAK,QAAO,GAAI;AAClB,UAAI,KAAK,YAAW,GAAI;AACtB,kBAAU;aACL;AACL,kBAAU;;;AAGd,SAAK,UAAS;AAEd,WAAO;EACT;;EAGQ,aAAa,MAAc,SAAS,OAAK;AAE/C,UAAM,YAAY,YAAY,IAAI;AAElC,QAAI,YAAY,eAAe,SAAS;AACxC,QAAI,QAAQ,KAAK,OAAO,EAAE,OAAO,MAAM,OAAO,UAAS,CAAE;AAGzD,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,UAAI,cAAc,YAAY,KAAK,WAAW,MAAM,CAAC,GAAG,KAAK,CAAC,GAAG;AAC/D,eAAO,MAAM,CAAC;;;AAKlB,QAAI,QAAQ;AACV,aAAO;;AAGT,QAAI,QAAQ;AACZ,QAAI,UAAU;AACd,QAAI,OAAO;AACX,QAAI,KAAK;AACT,QAAI,YAAY;AAmBhB,QAAI,sBAAsB;AAE1B,cAAU,UAAU,MAClB,4DAA4D;AAI9D,QAAI,SAAS;AACX,cAAQ,QAAQ,CAAC;AACjB,aAAO,QAAQ,CAAC;AAChB,WAAK,QAAQ,CAAC;AACd,kBAAY,QAAQ,CAAC;AAErB,UAAI,KAAK,UAAU,GAAG;AACpB,8BAAsB;;WAEnB;AAQL,gBAAU,UAAU,MAClB,8DAA8D;AAGhE,UAAI,SAAS;AACX,gBAAQ,QAAQ,CAAC;AACjB,eAAO,QAAQ,CAAC;AAChB,aAAK,QAAQ,CAAC;AACd,oBAAY,QAAQ,CAAC;AAErB,YAAI,KAAK,UAAU,GAAG;AACpB,gCAAsB;;;;AAK5B,gBAAY,eAAe,SAAS;AACpC,YAAQ,KAAK,OAAO;MAClB,OAAO;MACP,OAAO,QAAS,QAAwB;KACzC;AAED,QAAI,CAAC,IAAI;AACP,aAAO;;AAGT,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,UAAI,CAAC,MAAM;AAET,YACE,cACA,YAAY,KAAK,WAAW,MAAM,CAAC,GAAG,KAAK,CAAC,EAAE,QAAQ,KAAK,EAAE,GAC7D;AACA,iBAAO,MAAM,CAAC;;kBAIf,CAAC,SAAS,MAAM,YAAW,KAAM,MAAM,CAAC,EAAE,UAC3C,KAAK,IAAI,KAAK,MAAM,CAAC,EAAE,QACvB,KAAK,EAAE,KAAK,MAAM,CAAC,EAAE,OACpB,CAAC,aAAa,UAAU,YAAW,KAAM,MAAM,CAAC,EAAE,YACnD;AACA,eAAO,MAAM,CAAC;iBACL,qBAAqB;AAM9B,cAAM,SAAS,UAAU,MAAM,CAAC,EAAE,IAAI;AACtC,aACG,CAAC,SAAS,MAAM,YAAW,KAAM,MAAM,CAAC,EAAE,UAC3C,KAAK,EAAE,KAAK,MAAM,CAAC,EAAE,OACpB,QAAQ,OAAO,CAAC,KAAK,QAAQ,OAAO,CAAC,OACrC,CAAC,aAAa,UAAU,YAAW,KAAM,MAAM,CAAC,EAAE,YACnD;AACA,iBAAO,MAAM,CAAC;;;;AAKpB,WAAO;EACT;EAEA,QAAK;AACH,QAAI,IAAI;AACR,aAAS,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AAEvC,UAAI,KAAK,CAAC,MAAM,GAAG;AACjB,aAAK,MAAM,WAAW,KAAK,CAAC,CAAC,IAAI;;AAGnC,UAAI,KAAK,OAAO,CAAC,GAAG;AAClB,cAAM,QAAQ,KAAK,OAAO,CAAC,EAAE;AAC7B,cAAM,QAAQ,KAAK,OAAO,CAAC,EAAE;AAC7B,cAAM,SACJ,UAAU,QAAQ,MAAM,YAAW,IAAK,MAAM,YAAW;AAC3D,aAAK,MAAM,SAAS;aACf;AACL,aAAK;;AAGP,UAAK,IAAI,IAAK,KAAM;AAClB,aAAK;AACL,aAAK;;;AAGT,SAAK;AACL,SAAK;AAEL,WAAO;EACT;EAEA,MAAM,OAAa;AACjB,UAAM,QAAQ,KAAK,OAAO,EAAE,OAAO,MAAK,CAAE;AAC1C,QAAI,QAAQ;AACZ,UAAM,QAAQ,KAAK;AAEnB,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,WAAK,UAAU,MAAM,CAAC,CAAC;AACvB,UAAI,CAAC,KAAK,gBAAgB,KAAK,GAAG;AAChC,YAAI,QAAQ,IAAI,GAAG;AACjB,mBAAS,KAAK,MAAM,QAAQ,CAAC;eACxB;AACL;;;AAGJ,WAAK,UAAS;;AAGhB,WAAO;EACT;EAEA,OAAI;AACF,WAAO,KAAK;EACd;EAEA,QAAK;AACH,UAAM,SAAS,CAAA;AACf,QAAI,MAAM,CAAA;AAEV,aAAS,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AACvC,UAAI,KAAK,OAAO,CAAC,KAAK,MAAM;AAC1B,YAAI,KAAK,IAAI;aACR;AACL,YAAI,KAAK;UACP,QAAQ,UAAU,CAAC;UACnB,MAAM,KAAK,OAAO,CAAC,EAAE;UACrB,OAAO,KAAK,OAAO,CAAC,EAAE;SACvB;;AAEH,UAAK,IAAI,IAAK,KAAM;AAClB,eAAO,KAAK,GAAG;AACf,cAAM,CAAA;AACN,aAAK;;;AAIT,WAAO;EACT;EAEA,YAAY,QAAc;AACxB,QAAI,UAAU,MAAM;AAClB,YAAM,KAAK,KAAK,MAAM;AACtB,cAAQ,KAAK,EAAE,IAAI,KAAK,EAAE,KAAK,MAAM,IAAI,UAAU;;AAGrD,WAAO;EACT;EAMA,QAAQ,EAAE,UAAU,MAAK,IAA4B,CAAA,GAAE;AACrD,UAAM,kBAAkB,CAAA;AACxB,UAAM,cAAc,CAAA;AAEpB,WAAO,KAAK,SAAS,SAAS,GAAG;AAC/B,sBAAgB,KAAK,KAAK,UAAS,CAAE;;AAGvC,WAAO,MAAM;AACX,YAAM,OAAO,gBAAgB,IAAG;AAChC,UAAI,CAAC,MAAM;AACT;;AAGF,UAAI,SAAS;AACX,oBAAY,KAAK,IAAI,KAAK,MAAM,IAAI,CAAC;aAChC;AACL,oBAAY,KAAK,KAAK,WAAW,MAAM,KAAK,OAAM,CAAE,CAAC;;AAEvD,WAAK,UAAU,IAAI;;AAGrB,WAAO;EACT;;;;;;;EAQQ,kBAAkB,KAAW;AACnC,UAAM,aAAa,QAAQ,GAAG;AAC9B,WAAO,KAAK,eAAe,UAAU,KAAK;EAC5C;EAEQ,kBAAkB,KAAW;AACnC,UAAM,aAAa,QAAQ,GAAG;AAC9B,QAAI,KAAK,eAAe,UAAU,MAAM,QAAW;AACjD,WAAK,eAAe,UAAU,IAAI;;AAEpC,SAAK,eAAe,UAAU,KAAK;EACrC;EAEQ,kBAAkB,KAAW;AACnC,UAAM,aAAa,QAAQ,GAAG;AAC9B,QAAI,KAAK,eAAe,UAAU,MAAM,GAAG;AACzC,aAAO,KAAK,eAAe,UAAU;WAChC;AACL,WAAK,eAAe,UAAU,KAAK;;EAEvC;EAEQ,iBAAc;AACpB,UAAM,kBAAkB,CAAA;AACxB,UAAM,kBAA0C,CAAA;AAEhD,UAAM,cAAc,CAAC,QAAe;AAClC,UAAI,OAAO,KAAK,WAAW;AACzB,wBAAgB,GAAG,IAAI,KAAK,UAAU,GAAG;;IAE7C;AAEA,WAAO,KAAK,SAAS,SAAS,GAAG;AAC/B,sBAAgB,KAAK,KAAK,UAAS,CAAE;;AAGvC,gBAAY,KAAK,IAAG,CAAE;AAEtB,WAAO,MAAM;AACX,YAAM,OAAO,gBAAgB,IAAG;AAChC,UAAI,CAAC,MAAM;AACT;;AAEF,WAAK,UAAU,IAAI;AACnB,kBAAY,KAAK,IAAG,CAAE;;AAExB,SAAK,YAAY;EACnB;EAEA,aAAU;AACR,WAAO,KAAK,UAAU,KAAK,IAAG,CAAE;EAClC;EAEA,WAAW,SAAe;AACxB,SAAK,UAAU,KAAK,IAAG,CAAE,IAAI,QAAQ,QAAQ,KAAK,GAAG,EAAE,QAAQ,KAAK,GAAG;EACzE;;;;EAKA,gBAAa;AACX,WAAO,KAAK,cAAa;EAC3B;EAEA,gBAAa;AACX,UAAM,UAAU,KAAK,UAAU,KAAK,IAAG,CAAE;AACzC,WAAO,KAAK,UAAU,KAAK,IAAG,CAAE;AAChC,WAAO;EACT;EAEA,cAAW;AACT,SAAK,eAAc;AACnB,WAAO,OAAO,KAAK,KAAK,SAAS,EAAE,IAAI,CAAC,QAAe;AACrD,aAAO,EAAE,KAAU,SAAS,KAAK,UAAU,GAAG,EAAC;IACjD,CAAC;EACH;;;;EAKA,iBAAc;AACZ,WAAO,KAAK,eAAc;EAC5B;EAEA,iBAAc;AACZ,SAAK,eAAc;AACnB,WAAO,OAAO,KAAK,KAAK,SAAS,EAAE,IAAI,CAAC,QAAO;AAC7C,YAAM,UAAU,KAAK,UAAU,GAAG;AAClC,aAAO,KAAK,UAAU,GAAG;AACzB,aAAO,EAAE,KAAU,QAAgB;IACrC,CAAC;EACH;EAEA,kBACE,OACA,QAA4D;AAE5D,eAAW,QAAQ,CAAC,MAAM,KAAK,GAAY;AACzC,UAAI,OAAO,IAAI,MAAM,QAAW;AAC9B,YAAI,OAAO,IAAI,GAAG;AAChB,eAAK,UAAU,KAAK,KAAK,MAAM,IAAI;eAC9B;AACL,eAAK,UAAU,KAAK,KAAK,CAAC,MAAM,IAAI;;;;AAK1C,SAAK,sBAAqB;AAC1B,UAAM,SAAS,KAAK,kBAAkB,KAAK;AAE3C,YACG,OAAO,IAAI,MAAM,UAAa,OAAO,IAAI,MAAM,OAAO,IAAI,OAC1D,OAAO,KAAK,MAAM,UAAa,OAAO,KAAK,MAAM,OAAO,KAAK;EAElE;EAEA,kBAAkB,OAAY;AAC5B,WAAO;MACL,CAAC,IAAI,IAAI,KAAK,UAAU,KAAK,IAAI,MAAM,IAAI,OAAO;MAClD,CAAC,KAAK,IAAI,KAAK,UAAU,KAAK,IAAI,MAAM,KAAK,OAAO;;EAExD;EAEA,aAAU;AACR,WAAO,KAAK;EACd;;",
  "names": ["_a", "_b", "moveString", "headers"]
}
